#+title:     Pedagogical DMC Algorithms
#+author:    Vijay Gopal Chilkuri
#+email:     vijay.gopal.c@gmail.com
#+LATEX_HEADER: \usepackage{bbold}
#+LATEX_HEADER: \usepackage{braket}
#+LATEX_HEADER: \usepackage{amsmath,amssymb}

* Deterministic Algorithms

** Projector algorithm

*** Description

Projector algoithm relies on the fact that given
a trial wavefunction \(\nu\) with a non-zero overlap with
the exact wavefunction \(\mathbf{u}_0\), Eq:[[vecbasis]], a large number of application
of the Hamiltonian \(\hat{H}\) the series \(\left{\psi, \hat{H}\psi, \hat{H}^2\psi,\dots\) converges
to the exact wavefunction.

#+NAME: vecbasis
\begin{equation}
\mathbf{\nu} = c_0 \mathbf{u_0} + c_1 \mathbf{u_1}
\end{equation}

*** Example

The simplest example consists of a 2x2 Hamiltonian matrix
shown in Eq:[[mat2x2]]

#+NAME: mat2x2
#+ATTR_LATEX: :mode math :environment bmatrix :align cc
#+tblname: mat2x2
| v_0 | -t  |
| -t  | v_1 |

*** Code

**** Initialization

#+name: var2x2
#+begin_src julia
using Plots
using LaTeXStrings
using DataStructures
using Statistics
using LinearAlgebra
using Profile
using Revise

includet("srdmc.jl")

# Vars
nu0 =  1;
nu0 = 1;
nu1 = 2;
t=1;
# Trial energy
ET = 2.0
# Taux d'acceptation > 99%
tau = 0.02;
ET = 3.0;
c0=1/sqrt(2);
c1=1/sqrt(2);
nsteps = 2048;#1*8192;
niter = 40;
nruns = 100;
nwalker = 20;
ham=[nu0 -t; -t nu1];
vec0 = [c0, c1];
vec0 = vec0/norm(vec0);
e_exact,vec_exact = eigen(ham)
#+end_src

#+RESULTS: var2x2

#+name: var3x3
#+begin_src julia
using Plots
using LaTeXStrings
using DataStructures
using Statistics
using LinearAlgebra
using Profile

# Vars
nu0 = 1;
nu1 = 2;
nu2 = 3;
t=1;
# Trial energy
ET = 2.0
# Taux d'acceptation > 99%
tau = 0.05;
c0= 1.001/sqrt(3);
c1= 0.90001/sqrt(3);
c2= 0.80/sqrt(3);
nsteps = 4*8192;
niter = 40;
nruns = 100;
ham=[nu0 -t -t; -t nu1 -t; -t -t nu2]*1.0;
vec0 = [c0, c1, c2];
vec0 = vec0/norm(vec0);
e_exact,vec_exact = eigen(ham)
#+end_src

#+name: var6x6
#+begin_src julia
using Plots
using LaTeXStrings
using DataStructures
using Statistics
using LinearAlgebra
using Profile

# Vars
t=1;
# Trial energy
ET = 2.0
# Taux d'acceptation > 99%
tau = 0.10;
nu0 = 1+0;
nu1 = 2+0;
nu2 = 3+0;
nu3 = 4+0;
nu4 = 5+0;
nu5 = 6+0;
tau = 0.01;
c0= 1.00000
c1= 1.10000
c2= 1.01000
c3= 1.00100
c4= 1.10100
c5= 1.11010
ham=[nu0 -t   -t  -t  -t   -t;
     -t   nu1 -t  -t  -t   -t;
     -t   -t  nu2 -t  -t   -t;
     -t   -t  -t  nu3 -t   -t;
     -t   -t  -t  -t  nu4  -t;
     -t   -t  -t  -t  -t  nu5;]*1.0;
vec0 = [c0, c1, c2, c3, c4, c5];
vec0 = vec0/norm(vec0);
nsteps = 4*8192;
niter = 100;
nruns = 100;
e_exact,vec_exact = eigen(ham)
#+end_src

**** Algorithm

#+BEGIN_SRC julia :session j1 :results results :eval noexport :exports results
avgdataall = zeros(niter,2);
vec = vec0;
vec2 = vec0;
gh = Matrix(I,2,2) - tau * (ham - Matrix(I,2,2)*(ET));
gh2 = (ham - Matrix(I,2,2)*(ET));
for i in 1:niter
    avgdataall[i,1] = transpose(vec)*(ham*vec);
    avgdataall[i,2] = transpose(vec2)*(ham*vec2);
    vec = gh*vec;
    vec = vec/norm(vec);
    vec2 = gh2*vec2;
    vec2 = vec2/norm(vec2);
end
#avgdataall[:,2] = avgdataall[:,2] .+ ET;
plt=plot(collect(1:niter),avgdataall,
         xlabel=L"n",
         ylabel=L"E_0",
         xlims = (0,10),
#        ylims = (0.36,0.48),
         framestyle=:box,
         guidefontsize=10,
         legendfontsize=6,
         thickness_scaling=1.5,
         grid=:none,
         size=(400,600),
         )
#+end_src


* Stochastic Algorithm

** Pure Diffusion Monte Carlo

*** Description

The stochastic version of the algorithm consists
of two steps.

Step 1 - The calculation of the Energy.
    This is the variational step which is performed
    using variational Monte Carlo (VMC). Here we
    calculate the energy of the trial wavefunction \(\nu\).

Step 2 - The projection of the wavefunction.
    In this step, we perform the evolution of the
    wavefunction according to some diffusion process.
    There are different ways to carry out the projection
    and depending on the kernel used, one can obtain
    the following different methods:

    1. Evolution based on \(\hat{H}\) : Pure Diffusion Monte Carlo

    2. Evolution based on \(\hat{G}\) (the Green's function) :
       Greens Function Monte Carlo

       etc...

Here we use the PDMC version for the projection step.

*** Algorithm

**** VMC Step

The variational energy is estimated using VMC. In this step,
we evaluate \(\left<\nu|\hat{H}|\nu\right>\) stochastically for a given trial wavefunction \(\nu\). This is done using Metropolis sampling using the transition
probability given as in Eq:[[transprob]]:

#+NAME: transprob
\begin{equation}
P_{i\rightarrow j} = \frac{c_j}{c_i}\left[ \mathbb{1} - \tau\left( \hat{H} - E_L\right) \right]_{ij}
\end{equation}

This probability corresponds to the Metropolis acceptance
probability. To generate the Markov chain, a random number
is generated and the state for a given \(i\) is chosen
from all the candidate states according to the rule below:

#+NAME: acceptancerule
\begin{align}
j_1\ &\text{if}\ \xi \in (0,\mathcal{P}_1) \\
j_2\ &\text{if}\ \xi \in (\mathcal{P}_1,\mathcal{P}_1 + \mathcal{P}_2)\\
j_k\ &\text{if}\ \xi \in (\sum_{k-1}\mathcal{P}_k,\sum_{k}\mathcal{P}_k )
\end{align}

At each MC step, the local energy is evaluated using Eq:[[elocal1]]

#+NAME: elocal1
\begin{equation}
[E_{L}]_{ij} = \delta_{ij}E_L(i)
\end{equation}

#+NAME: elocal2
\begin{equation}
E_{L}(i) = \frac{[\hat{H}\mathbf{\nu}]_i}{v_i}
\end{equation}

The VMC energy is evaluate as the mean of the values for
each MC step in the Markov chain Eq:[[vmcenergy]]

#+NAME: vmcenergy
\begin{equation}
E_{0}(0) = \frac{E_L(i_0) + E_L(i_1) + E_L(i_2) + \dots}
{1 + 1 + 1 + \dots}
\end{equation}

***** Code

#+name: calc_local_energy
#+begin_src julia
function getEL(ham, vi, i)
    if(vi[i]==0.0)
        return typemax(Float64)
    else
        return ((ham*vi)[i]/vi[i])
    end
end
#+end_src

#+name: prepare_pij_list
#+begin_src julia
function getPij(ham, tau, i, j, vec)
    dim = size(ham)[1];
    idmat = Matrix(1.0*I,dim,dim);
    EL = zeros(dim,dim)
    for k in 1:dim
        EL[k,k] = getEL(ham,vec,k)
    end
    numer = vec[j] * (idmat - tau * (ham - EL))[i,j];
    denom = vec[i];
    if(denom==0.0)
        return typemax(Float64)
    else
        return(numer/denom)
    end
end
#+end_src

#+name: swap_states
#+begin_src julia
function doSwap(randval, j, pij, pijids)
   return(pijids[j,searchsortedfirst(collect(keys(pij[j])),randval)])
end
#+end_src

#+name: prepare_pij_lists
#+begin_src julia
function prepare_pij(ham, vec, ET, tau)
    dim = size(ham)[1];
    pij = SortedDict{Any, Any}[SortedDict() for i = 1:dim];
    countswaps = zeros(dim);
    elij = Dict();
    for i in 1:dim
        for j in 1:dim
            EL = getEL(ham, vec, i)
            EL1 = EL;
            p12 = getPij(ham, tau, i, j, vec)
            if(i==j)
                elij[i] = EL;
            end
            pij[i][p12] = j
        end
    end
    # take sum of Pij
    pijidsSorted = zeros(Int,dim,dim);
    pijsummed = SortedDict{Any, Any}[SortedDict() for i = 1:dim];
    for i in 1:dim
        map(x->pijsummed[i][foldl(+,collect(keys(pij[i]))[1:x])]=collect(values(pij[i]))[x],1:length(pij[i]))
        pijidsSorted[i,1:dim] = collect(values(pijsummed[i]))
    end
    return(pijsummed,pijidsSorted, elij)
end
#+end_src

#+name: vmc_algo
#+begin_src julia
pijsummed,pijidsSorted, elij = prepare_pij(ham, vec0, ET, tau);
localenergy = zeros(nruns);
for irun in 1:nruns
    elocal = 0.0;
    j = 1;
    for istep in 1:nsteps
        j = doSwap(rand(),j,pijsummed,pijidsSorted);
        elocal += elij[j];
        i = j;
    end
    localenergy[irun] = elocal/nsteps;
end
mean(localenergy)
var(localenergy)
#+end_src


**** PDMC Step

***** Formulae

PDMC is the step which performs the projection i.e.
the application of \(\hat{H}\) on the trial wavefunction \(\nu\). This
is acheived using weights \(w_{ij}\) which take into account
the trial density differs from the exact density.

The weights \(w_{ij}\) are defined as shown in Eq:[[weights]]

#+NAME: weights
\begin{equation}
w_{ij} = \frac
{\left[ \mathbb{1} - \tau\left( \hat{H} - E_T\right) \right]_{ij}}
{\left[ \mathbb{1} - \tau\left( \hat{H} - E_L\right) \right]_{ij}}
\end{equation}

The weights have the property that the extra-diagonal
element of the weight matrix \(w_{ij}\) is \(1\)
whereas the diagonal element \(w_{ii}\) is proportional to the
ratio of \(E_T\) over \(E_L(i)\) Eq:[[weightdiag]].

#+NAME: weightdiag
\begin{equation}
w_{ii} = \frac
{\left[ \left(\mathbb{1} - \tau H_{ii})+\tau E_T\right \right]}
{\left[ \left(\mathbb{1} - \tau H_{ii})+\tau E_L(i)\right \right]}
\end{equation}

Weights favor those states in the Markov chain which have
a lower local energy \(E_L(i)\).

***** Code

#+name: getweights
#+begin_src julia
function getWeightij(ham, tau, ET, i, j,ELi)
    if(i!=j)
        return(1.0);
    else
        numer = (1.0 - tau * ham[i,i] + tau * ET);
        denom = (1.0 - tau * ham[i,i] + tau * ELi);
        if(denom==0.0)
            return typemax(Float64)
        else
            return(numer/denom)
        end
    end
end
#+end_src

#+name: prepare_pij_lists_with_weights
#+begin_src julia
function prepare_pij_wij(ham, vec, ET, tau)
    dim = size(ham)[1];
    pij = SortedDict{Any, Any}[SortedDict() for i = 1:dim];
    countswaps = zeros(dim);
    elij = Dict();
    weightij = Dict();
    for i in 1:dim
        for j in 1:dim
            EL = getEL(ham, vec, i)
            EL1 = EL;
            w12 = getWeightij(ham, tau, ET, i, j, EL);
            p12 = getPij(ham, tau, i, j, vec)
            if(i==j)
                elij[i] = EL;
            end
            pij[i][p12] = j
            weightij[(i,j)] = w12
        end
    end
    # take sum of Pij
    pijidsSorted = zeros(Int,dim,dim);
    pijsummed = SortedDict{Any, Any}[SortedDict() for i = 1:dim];
    for i in 1:dim
        map(x->pijsummed[i][foldl(+,collect(keys(pij[i]))[1:x])]=collect(values(pij[i]))[x],1:length(pij[i]))
        pijidsSorted[i,1:dim] = collect(values(pijsummed[i]))
    end
    return(pijsummed,pijidsSorted, elij, weightij)
end
#+end_src

#+name: pdmc_algo_simple
#+begin_src julia
niter = 3;
pijsummed,pijidsSorted, elij, weightij = prepare_pij_wij(ham, vec0, ET, tau);
localenergy = zeros(nruns,niter);
weightslist = zeros(niter);
for irun in 1:nruns
    # E_0
    elocal = 0.0;
    j = 1;
    i = j;
    for istep in 1:nsteps
        j = doSwap(rand(),j,pijsummed,pijidsSorted);
        elocal += elij[j];
        i = j;
    end
    localenergy[irun,1] = elocal/nsteps;
    # E_1
    elocal = 0.0;
    wlocal = 0.0;
    j = 1;
    i = j;
    for istep in 1:nsteps
        j = doSwap(rand(),j,pijsummed,pijidsSorted);
        weightslist[1] = weightij[(i,j)];
        elocal += elij[j]*weightslist[1];
        wlocal += weightslist[1];
        i = j;
    end
    localenergy[irun,2] = elocal/wlocal;
    # E_2
    elocal = 0.0;
    wlocal = 1.0;
    wlocaltot = 0.0;
    wlocalprev = 1.0;
    j = 1;
    j = doSwap(rand(),j,pijsummed,pijidsSorted);
    wlocal *= weightij[(i,j)];
    weightslist[1] = weightij[(i,j)];
    i = j;
    j = doSwap(rand(),j,pijsummed,pijidsSorted);
    wlocal *= weightij[(i,j)];
    weightslist[2] = weightij[(i,j)];
    i = j;
    for istep in 1:nsteps
        elocal += elij[j]*wlocal;
        wlocaltot += wlocal;
        j = doSwap(rand(),j,pijsummed,pijidsSorted);
        wlocalprev = weightslist[((istep-1)%2)+1];
        wlocal = wlocal * weightij[(i,j)]/wlocalprev;
        weightslist[((istep-1)%2)+1] = weightij[(i,j)];
        i = j;
    end
    localenergy[irun,3] = elocal/wlocaltot;
end
mean(localenergy[:,1])
var(localenergy[:,1])
mean(localenergy[:,2])
var(localenergy[:,2])
mean(localenergy[:,3])
var(localenergy[:,3])
#+end_src

#+name: pdmc_algo
#+begin_src julia
function do_PDMC(ham, vec0, ET, tau, nruns, niter, nsteps)
    pijsummed, pijidsSorted, elij, weightij = prepare_pij_wij(ham, vec0, ET, tau);
    localenergy = zeros(nruns, niter);
    weightlist = zeros(niter);
    prodweightlist = zeros(niter);
    #prodweightlist_per_i = zeros(niter);
    idweightlist = zeros(niter);
    for irun in 1:nruns
        # Initialize lists
        elocaltot = zeros(niter);
        wlocaltot = zeros(niter);
        j = 1;
        i = j;
        wlocal = 1.0;

        # Prepare weight list
        for it in 1:niter
            # Perform MC step
            j = doSwap(rand(),j,pijsummed,pijidsSorted);

            # Initialize weightlist
            weightlist[it] = weightij[(i,j)];

            # Save current state
            i = j;
        end

        # Prepare prodweightlist
        for it in niter:-1:1
            prodweightlist[niter-it+1] = wlocal * weightlist[it];
            wlocal = wlocal * weightlist[it];
        end

        # Do PDMC
        for istep in 1:nsteps
            # Calculate elocal and wlocal
            for it in 1:niter
               elocaltot[it] += elij[j] * prodweightlist[it];
               wlocaltot[it] += prodweightlist[it];
            end
            #if(j == 5)
            #    prodweightlist_per_i .+= prodweightlist;
            #end

            # Perform MC step
            j = doSwap(rand(),j,pijsummed,pijidsSorted);

            # Calculate new weights
            wlocal = weightij[(i,j)];
            for it in 1:niter-1
                idxdel = (((istep-1 + (niter-it)) % niter) + 1);
                #idxnew = (((istep-1 + (niter-1 )) % niter) + 1);
                #idxnew = (((istep) % niter) + 0);
                wprev = weightlist[idxdel];
                #wnew  = weightlist[idxnew];
                wnew  = wlocal;
                prodweightlist[it] = prodweightlist[it] * wnew/wprev;
            end
            idxnew = (((istep-1) % niter) + 1);
            wprev = weightlist[idxnew];
            weightlist[idxnew] = weightij[(i,j)];
            prodweightlist[niter] = prodweightlist[niter] * wlocal/wprev;

            # Save current state
            i = j;
        end

        # Fill global list
        for it in 1:niter
            localenergy[irun,it] = elocaltot[it]/wlocaltot[it];
            #localenergy[irun,it] = prodweightlist_per_i[it]/nsteps;
        end
    end
    return(localenergy);
end
#+end_src

#+name: testing
#+begin_src julia
localenergy = do_PDMC(ham, vec0, ET, tau, nruns, niter, nsteps);
println(mean(localenergy[:,1]),var(localenergy[:,1]))
println(mean(localenergy[:,2]),var(localenergy[:,2]))
println(mean(localenergy[:,3]),var(localenergy[:,3]))
#+end_src

***** Plots

#+BEGIN_SRC jupyter-julia :session j1 :results results :eval noexport :exports results #:tangle pdmc.jl
meanenerlist = zeros(niter);
varenerlist = zeros(niter);
localenergy = do_PDMC(ham, vec0, ET, tau, nruns, niter, nsteps);
for it in 1:niter
    meanenerlist[it] = mean(localenergy[:,it]);
    varenerlist[it] = var(localenergy[:,it]);
end
plt=plot(collect(1:niter),meanenerlist,
         xlabel=L"n",
         ylabel=L"E_0",
#        lw=2,
         xlims = (0,niter),
         ylims = (-2.0,-1.4),
         framestyle=:box,
         guidefontsize=10,
         legendfontsize=6,
         thickness_scaling=1.5,
         grid=:none,
#        marker=true,
#        markersize=2,
         size=(400,600),
         ribbon=varenerlist
         )
hline!([-1.97],line=:dash)
#+end_src


** Diffusion Monte Carlo

*** Algorithm

***** Code

#+name: dmc_algo
#+begin_src julia :tangle srdmc.jl
function do_SRDMC(ham, vec0, ET, tau, nruns, niter, nsteps, nwalker)
    pijsummed, pijidsSorted, elij, weightij = prepare_pij_wij(ham, vec0, ET, tau);
    println(weightij);
    localenergy = zeros(nruns, niter);
    weightlist = zeros(nwalker,niter);
    prodweightlist = zeros(nwalker,niter);
    idweightlist = zeros(nwalker,niter);
    walkerlisti = zeros(Int64,nwalker)
    walkerlistj = zeros(Int64,nwalker)
    newwalkerlistj = zeros(Int64,nwalker)
    weightlistscaled = zeros(Float64,nwalker)
    problistj = zeros(Float64,nwalker)
    for irun in 1:nruns
        # Initialize lists
        elocaltot = zeros(niter);
        wlocaltot = zeros(niter);
        j = 1;
        i = j;
        walkerlistj .= 1;
        walkerlisti .= 1;
        wlocal = 1.0;

        # Prepare weight list
        for it in 1:niter
            # Perform MC step for each walker
            for nw in 1:nwalker
                j = walkerlistj[nw];
                i = walkerlisti[nw];
                walkerlistj[nw] = doSwap(rand(),j,pijsummed,pijidsSorted);
                j = walkerlistj[nw];

                # Initialize weightlist
                weightlist[nw,it] = weightij[(i,j)];

                # Save current state
                walkerlisti[nw] = walkerlistj[nw];
            end
        end

        # Prepare prodweightlist
        for it in niter:-1:1
            for nw in 1:nwalker
                prodweightlist[nw,niter-it+1] = wlocal * weightlist[nw,it];
                wlocal = wlocal * weightlist[nw,it];
            end
        end

        # Do PDMC
        for istep in 1:nsteps
            # Calculate elocal and wlocal
            for it in 1:niter
                elocaltotperw = 0.0;
                wlocaltotperw = 0.0;
                for nw in 1:nwalker
                    elocaltotperw += elij[walkerlistj[nw]] * prodweightlist[nw,it];
                    wlocaltotperw += prodweightlist[nw,it];
                end
                elocaltot[it] += elocaltotperw/nwalker;
                wlocaltot[it] += wlocaltotperw/nwalker;
            end

            #println("iter --- ",istep," ----");
            #println(walkerlistj);
            # Perform MC step for each walker
            for nw in 1:nwalker
                j = walkerlistj[nw];
                i = walkerlisti[nw];
                walkerlistj[nw] = doSwap(rand(),j,pijsummed,pijidsSorted);
                j = walkerlistj[nw];

                # Calculate new weights
                wlocal = weightij[(i,j)];
                #println(wlocal);
                for it in 1:niter-1
                    idxdel = (((istep-1 + (niter-it)) % niter) + 1);
                    wprev = weightlist[nw,idxdel];
                    wnew  = wlocal;
                    #prodweightlist[nw,it] = prodweightlist[nw,it] * wnew/wprev;
                    prodweightlist[nw,it] = 1.0;
                end
                idxnew = (((istep-1) % niter) + 1);
                wprev = weightlist[nw,idxnew];
                weightlist[nw,idxnew] = weightij[(i,j)];
                #prodweightlist[nw,niter] = prodweightlist[nw,niter] * wlocal/wprev;
                prodweightlist[nw,niter] = 1.0;

                # Save current state
                walkerlisti[nw] = walkerlistj[nw];
            end

            # Branching

            # Calculate probability list
            idxnew = (((istep-1) % niter) + 1);
            totweightlist = sum(weightlist[:,idxnew]);
            weightlistscaled = weightlist[:,idxnew]/totweightlist;
            for nw in 1:nwalker
                problistj[nw] = sum(weightlistscaled[1:nw]);
            end
            #println(weightlist[:,idxnew]);
            #println(walkerlistj);
            #println(problistj);
            #println("old j==1");
            #println(sum(map(x->x==1,walkerlistj)));
            newwalkerlistj = branch_dmc(problistj, walkerlistj, nwalker);
            walkerlistj = newwalkerlistj;
            #println("new j==1");
            #println(sum(map(x->x==1,walkerlistj)));

            # Save j in i
            walkerlisti = walkerlistj;

        end

        # Fill global list
        for it in 1:niter
            localenergy[irun,it] = elocaltot[it]/wlocaltot[it];
        end
    end
    return(localenergy);
end
#+end_src

#+name: branching
#+begin_src julia :tangle srdmc.jl
function branch_dmc(problist,walkerlist,nwalker)
    # Make new walker list
    newwalkerlist = zeros(Int64,nwalker);
    swap12 = Dict();
    swap12[1] = 1;
    swap12[2] = 2;
    #swap12[3] = 3;
    #swap12[4] = 4;
    #swap12[5] = 5;
    #swap12[6] = 6;
    for nw in 1:nwalker
        newwalkerlist[nw] = swap12[walkerlist[searchsortedfirst(problist, rand())]];
    end
    return(newwalkerlist);
end
#+end_src

***** Plots

#+BEGIN_SRC jupyter-julia :session j1 :results results :eval noexport :exports results #:tangle pdmc.jl
meanenerlist = zeros(niter);
varenerlist = zeros(niter);
localenergy = do_SRDMC(ham, vec0, ET, tau, nruns, niter, nsteps, nwalker);
for it in 1:niter
    meanenerlist[it] = mean(localenergy[:,it]);
    varenerlist[it] = var(localenergy[:,it]);
end
plt=plot(collect(1:niter),meanenerlist,
         xlabel=L"n",
         ylabel=L"E_0",
#        lw=2,
         xlims = (0,niter),
         #ylims = (-2.0,-1.4),
         framestyle=:box,
         guidefontsize=10,
         legendfontsize=6,
         thickness_scaling=1.5,
         grid=:none,
#        marker=true,
#        markersize=2,
         size=(400,600),
         ribbon=varenerlist
         )
hline!([-1.97],line=:dash)
#+end_src

* Testing

#+begin_src julia :results output
tmpnmax = 16
tmparray = zeros(tmpnmax);
map(x->tmparray[x]=x,collect(1:tmpnmax));
for i in 1:tmpnmax
    idx8 = (((i-1)%8)+1)
    idx5 = (((i-1 + 3)%8)+1)
    idx4 = (((i-1 + 4)%8)+1)
    idx3 = (((i-1 + 5)%8)+1)
    println(idx8,"\t",tmparray[idx8])
    println("\t---",idx5, "\t---",idx4, "\t---",idx3)
    idx5 = (((i-1 + 3 + 5 - 1)%8)+1)
    idx4 = (((i-1 + 4 + 4 - 1)%8)+1)
    idx3 = (((i-1 + 5 + 3 - 1)%8)+1)
    println("\t---",idx5, "\t---",idx4, "\t---",idx3)
end
#+end_src

#+RESULTS:

--------    --------    --------    --------
12345678    12345678    12345678    12345678
***-----    ****----    *****---    ******--
   12345        1234         123          12

--------    --------    --------    --------
12345678    12345678    12345678    12345678
-***----    -****---    -*****--    -******-
5   1234    4    123    3     12    2      1

--------    --------    --------    --------
12345678    12345678    12345678    12345678
--***---    --****--    --*****-    --******
45   123    34    12    23     1    12
