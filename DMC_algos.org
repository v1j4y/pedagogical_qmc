#+title:     Pedagogical DMC Algorithms
#+author:    Vijay Gopal Chilkuri
#+email:     vijay.gopal.c@gmail.com
#+LATEX_HEADER: \usepackage{bbold}
#+LATEX_HEADER: \usepackage{braket}
#+LATEX_HEADER: \usepackage{amsmath,amssymb}

* Deterministic Algorithms

** Projector algorithm

*** Description

Projector algoithm relies on the fact that given
a trial wavefunction \(\nu\) with a non-zero overlap with
the exact wavefunction \(\mathbf{u}_0\), Eq:[[vecbasis]], a large number of application
of the Hamiltonian \(\hat{H}\) the series \(\left{\psi, \hat{H}\psi, \hat{H}^2\psi,\dots\) converges
to the exact wavefunction.

#+NAME: vecbasis
\begin{equation}
\mathbf{\nu} = c_0 \mathbf{u_0} + c_1 \mathbf{u_1}
\end{equation}

*** Example

The simplest example consists of a 2x2 Hamiltonian matrix
shown in Eq:[[mat2x2]]

#+NAME: mat2x2
#+ATTR_LATEX: :mode math :environment bmatrix :align cc
#+tblname: mat2x2
| v_0 | -t  |
| -t  | v_1 |

*** Code

**** Initialization

***** Bosonic

#+name: var2x2
#+begin_src julia
using Plots
using LaTeXStrings
using DataStructures
using Statistics
using LinearAlgebra
using Profile
using Revise
using DelimitedFiles

includet("srdmc.jl")

# Vars
nu0 =  1;
nu0 =1;
nu1 =2;
t=1;
# Trial energy
ET = 2.0
# Taux d'acceptation > 99%
tau = 0.10;
ET = 2.0;
c0=1/sqrt(2);
c1=1/sqrt(2);
nsteps = 4*8192;
niter = 400;
nruns = 200;
nwalker = 20;
ham=[nu0 -t; -t nu1];
vec0 = [c0, c1];
vec0 = vec0/norm(vec0);
e_exact,vec_exact = eigen(ham)
#+end_src

#+name: var3x3
#+begin_src julia
using Plots
using LaTeXStrings
using DataStructures
using Statistics
using LinearAlgebra
using Profile
using Revise
using DelimitedFiles

includet("srdmc.jl")
# Vars
nu0 = 0;
nu1 = 1;
nu2 = 10;
t=1;
# Trial energy
ET = -0.1
# Taux d'acceptation > 99%
tau = 0.01;
c0= 1.001/sqrt(3);
c1= 0.90001/sqrt(3);
c2= 0.80/sqrt(3);
nsteps = 1*8192;
niter = 40;
nruns = 100;
nwalker = 20;
ham=[nu0 -t -t; -t nu1 -t; -t -t nu2]*1.0;
vec0 = [c0, c1, c2];
vec0 = vec0/norm(vec0);
e_exact,vec_exact = eigen(ham)
#+end_src

#+name: var6x6
#+begin_src julia
using Plots
using LaTeXStrings
using DataStructures
using Statistics
using LinearAlgebra
using Profile
using Revise
using DelimitedFiles

includet("srdmc.jl")
# Vars
t=1;
# Trial energy
ET = 2.0
# Taux d'acceptation > 99%
tau = 0.10;
nu0 = 1+0;
nu1 = 2+0;
nu2 = 3+0;
nu3 = 4+0;
nu4 = 5+0;
nu5 = 6+0;
tau = 0.01;
c0= 1.00000
c1= 1.10000
c2= 1.01000
c3= 1.00100
c4= 1.10100
c5= 1.11010
ham=[nu0 -t   -t  -t  -t   -t;
     -t   nu1 -t  -t  -t   -t;
     -t   -t  nu2 -t  -t   -t;
     -t   -t  -t  nu3 -t   -t;
     -t   -t  -t  -t  nu4  -t;
     -t   -t  -t  -t  -t  nu5;]*1.0;
vec0 = [c0, c1, c2, c3, c4, c5];
vec0 = vec0/norm(vec0);
nsteps = 2048;#4*8192;
niter = 100;
nruns = 100;
e_exact,vec_exact = eigen(ham)
#+end_src

***** Heisenberg

#+name: heis8x8
#+begin_src julia
using Plots
using LaTeXStrings
using DataStructures
using Statistics
using LinearAlgebra
using Profile
using Revise
using DelimitedFiles

includet("srdmc.jl")

# Vars
dimham = 6;
# Trial energy
ET = 2.0
# Taux d'acceptation > 99%
tau = 0.010;
c0=1/sqrt(2);
c1=1/sqrt(2);
nsteps = 1*8192;
niter = 200;
nruns = 200;
nwalker = 40;
ham=readdlm("/tmp/ham4x4.txt",'\t',Float64,'\n');
ham = ham;# - Diagonal([2.0, 2.0, 2.0, 2.0, 2.0, 2.0]);
vec0 = zeros(Float64,dimham);
vec0 = rand(dimham);
vec0[1] = vec0[6];
vec0[2] = vec0[5];
vec0[3] = vec0[4];
jastrow = [1/4;3/4;1/4;1/4;3/4;1/4];
vec0 = vec0 .* jastrow;
vec0 = vec0/norm(vec0);
e_exact,vec_exact = eigen(ham)
#+end_src

**** Algorithm

#+BEGIN_SRC julia :session j1 :results results :eval noexport :exports results
avgdataall = zeros(niter,2);
vec = vec0;
vec2 = vec0;
gh = Matrix(I,2,2) - tau * (ham - Matrix(I,2,2)*(ET));
gh2 = (ham - Matrix(I,2,2)*(ET));
for i in 1:niter
    avgdataall[i,1] = transpose(vec)*(ham*vec);
    avgdataall[i,2] = transpose(vec2)*(ham*vec2);
    vec = gh*vec;
    vec = vec/norm(vec);
    vec2 = gh2*vec2;
    vec2 = vec2/norm(vec2);
end
#avgdataall[:,2] = avgdataall[:,2] .+ ET;
plt=plot(collect(1:niter),avgdataall,
         xlabel=L"n",
         ylabel=L"E_0",
         xlims = (0,10),
#        ylims = (0.36,0.48),
         framestyle=:box,
         guidefontsize=10,
         legendfontsize=6,
         thickness_scaling=1.5,
         grid=:none,
         size=(400,600),
         )
#+end_src


* Stochastic Algorithm

** Pure Diffusion Monte Carlo

*** Description

The stochastic version of the algorithm consists
of two steps.

Step 1 - The calculation of the Energy.
    This is the variational step which is performed
    using variational Monte Carlo (VMC). Here we
    calculate the energy of the trial wavefunction \(\nu\).

Step 2 - The projection of the wavefunction.
    In this step, we perform the evolution of the
    wavefunction according to some diffusion process.
    There are different ways to carry out the projection
    and depending on the kernel used, one can obtain
    the following different methods:

    1. Evolution based on \(\hat{H}\) : Pure Diffusion Monte Carlo

    2. Evolution based on \(\hat{G}\) (the Green's function) :
       Greens Function Monte Carlo

       etc...

Here we use the PDMC version for the projection step.

*** Algorithm

**** VMC Step
***** Theory

The variational energy is estimated using VMC. In this step,
we evaluate \(\left<\nu|\hat{H}|\nu\right>\) stochastically for a given trial wavefunction \(\nu\). This is done using Metropolis sampling using the transition
probability given as in Eq:[[transprob]]:

#+NAME: transprob
\begin{equation}
P_{i\rightarrow j} = \frac{c_j}{c_i}\left[ \mathbb{1} - \tau\left( \hat{H} - E_L\right) \right]_{ij}
\end{equation}

This probability corresponds to the Metropolis acceptance
probability. To generate the Markov chain, a random number
is generated and the state for a given \(i\) is chosen
from all the candidate states according to the rule below:

#+NAME: acceptancerule
\begin{align}
j_1\ &\text{if}\ \xi \in (0,\mathcal{P}_1) \\
j_2\ &\text{if}\ \xi \in (\mathcal{P}_1,\mathcal{P}_1 + \mathcal{P}_2)\\
j_k\ &\text{if}\ \xi \in (\sum_{k-1}\mathcal{P}_k,\sum_{k}\mathcal{P}_k )
\end{align}

At each MC step, the local energy is evaluated using Eq:[[elocal1]]

#+NAME: elocal1
\begin{equation}
[E_{L}]_{ij} = \delta_{ij}E_L(i)
\end{equation}

#+NAME: elocal2
\begin{equation}
E_{L}(i) = \frac{[\hat{H}\mathbf{\nu}]_i}{v_i}
\end{equation}

The VMC energy is evaluate as the mean of the values for
each MC step in the Markov chain Eq:[[vmcenergy]]

#+NAME: vmcenergy
\begin{equation}
E_{0}(0) = \frac{E_L(i_0) + E_L(i_1) + E_L(i_2) + \dots}
{1 + 1 + 1 + \dots}
\end{equation}

***** Code

#+name: calc_local_energy
#+begin_src julia :tangle srdmc.jl
function getEL(ham, vi, i)
    if(vi[i]==0.0)
        return typemax(Float64)
    else
        return ((ham*vi)[i]/vi[i])
    end
end
#+end_src

#+name: prepare_pij_list
#+begin_src julia :tangle srdmc.jl
function getPij(ham, tau, i, j, vec)
    dim = size(ham)[1];
    idmat = Matrix(1.0*I,dim,dim);
    EL = zeros(dim,dim)
    for k in 1:dim
        EL[k,k] = getEL(ham,vec,k)
    end
    numer = vec[j] * (idmat - tau * (ham - EL))[i,j];
    denom = vec[i];
    if(denom==0.0)
        return typemax(Float64)
    else
        return(numer/denom)
    end
end
#+end_src

#+name: swap_states
#+begin_src julia :tangle srdmc.jl
function doSwap(randval, j, pij, pijids)
   return(pijids[j,searchsortedfirst(collect(values(pij[j])),randval)])
end
#+end_src

#+name: prepare_pij_lists
#+begin_src julia :tangle srdmc.jl
function prepare_pij(ham, vec, ET, tau)
    dim = size(ham)[1];
    pij = SortedDict{Any, Any}[SortedDict() for i = 1:dim];
    countswaps = zeros(dim);
    elij = Dict();
    for i in 1:dim
        for j in 1:dim
            EL = getEL(ham, vec, i)
            EL1 = EL;
            p12 = getPij(ham, tau, i, j, vec)
            if(i==j)
                elij[i] = EL;
            end
            pij[i][p12] = j
        end
    end
    # take sum of Pij
    pijidsSorted = zeros(Int,dim,dim);
    pijsummed = SortedDict{Any, Any}[SortedDict() for i = 1:dim];
    for i in 1:dim
        map(x->pijsummed[i][collect(values(pij[i]))[x]]=foldl(+,collect(keys(pij[i]))[1:x]),1:length(pij[i]))
        pijidsSorted[i,1:dim] = collect(keys(pijsummed[i]))
    end
    return(pijsummed,pijidsSorted, elij)
end
#+end_src

#+name: vmc_algo
#+begin_src julia
pijsummed,pijidsSorted, elij = prepare_pij(ham, vec0, ET, tau);
localenergy = zeros(nruns);
for irun in 1:nruns
    elocal = 0.0;
    j = 1;
    for istep in 1:nsteps
        j = doSwap(rand(),j,pijsummed,pijidsSorted);
        elocal += elij[j];
        i = j;
    end
    localenergy[irun] = elocal/nsteps;
end
mean(localenergy)
var(localenergy)
#+end_src


**** PDMC Step

***** Formulae

PDMC is the step which performs the projection i.e.
the application of \(\hat{H}\) on the trial wavefunction \(\nu\). This
is acheived using weights \(w_{ij}\) which take into account
the trial density differs from the exact density.

The weights \(w_{ij}\) are defined as shown in Eq:[[weights]]

#+NAME: weights
\begin{equation}
w_{ij} = \frac
{\left[ \mathbb{1} - \tau\left( \hat{H} - E_T\right) \right]_{ij}}
{\left[ \mathbb{1} - \tau\left( \hat{H} - E_L\right) \right]_{ij}}
\end{equation}

The weights have the property that the extra-diagonal
element of the weight matrix \(w_{ij}\) is \(1\)
whereas the diagonal element \(w_{ii}\) is proportional to the
ratio of \(E_T\) over \(E_L(i)\) Eq:[[weightdiag]].

#+NAME: weightdiag
\begin{equation}
w_{ii} = \frac
{\left[ \left(\mathbb{1} - \tau H_{ii})+\tau E_T\right \right]}
{\left[ \left(\mathbb{1} - \tau H_{ii})+\tau E_L(i)\right \right]}
\end{equation}

Weights favor those states in the Markov chain which have
a lower local energy \(E_L(i)\).

***** Code

#+name: getweights
#+begin_src julia :tangle srdmc.jl
function getWeightij(ham, tau, ET, i, j,ELi)
    if(i!=j)
        return(1.0);
    else
        numer = (1.0 - tau * ham[i,i] + tau * ET);
        denom = (1.0 - tau * ham[i,i] + tau * ELi);
        if(denom==0.0)
            return typemax(Float64)
        else
            return(numer/denom)
        end
    end
end
#+end_src

#+name: prepare_pij_lists_with_weights
#+begin_src julia :tangle srdmc.jl
function prepare_pij_wij(ham, vec, ET, tau)
    dim = size(ham)[1];
    pij = SortedDict{Any, Any}[SortedDict() for i = 1:dim];
    countswaps = zeros(dim);
    elij = Dict();
    weightij = Dict();
    for i in 1:dim
        for j in 1:dim
            EL = getEL(ham, vec, i)
            EL1 = EL;
            w12 = getWeightij(ham, tau, ET, i, j, EL);
            p12 = getPij(ham, tau, i, j, vec)
            if(i==j)
                elij[i] = EL;
            end
            pij[i][j] = p12;
            weightij[(i,j)] = w12
        end
    end
    # take sum of Pij
    pijidsSorted = zeros(Int,dim,dim);
    pijsummed = SortedDict{Any, Any}[SortedDict() for i = 1:dim];
    for i in 1:dim
        map(x->pijsummed[i][collect(keys(pij[i]))[x]]=foldl(+,collect(values(pij[i]))[1:x]),1:length(pij[i]))
        pijidsSorted[i,1:dim] = collect(keys(pijsummed[i]))
    end
    return(pijsummed,pijidsSorted, elij, weightij)
end
#+end_src

#+name: pdmc_algo_simple
#+begin_src julia
niter = 3;
pijsummed,pijidsSorted, elij, weightij = prepare_pij_wij(ham, vec0, ET, tau);
localenergy = zeros(nruns,niter);
weightslist = zeros(niter);
for irun in 1:nruns
    # E_0
    elocal = 0.0;
    j = 1;
    i = j;
    for istep in 1:nsteps
        j = doSwap(rand(),j,pijsummed,pijidsSorted);
        elocal += elij[j];
        i = j;
    end
    localenergy[irun,1] = elocal/nsteps;
    # E_1
    elocal = 0.0;
    wlocal = 0.0;
    j = 1;
    i = j;
    for istep in 1:nsteps
        j = doSwap(rand(),j,pijsummed,pijidsSorted);
        weightslist[1] = weightij[(i,j)];
        elocal += elij[j]*weightslist[1];
        wlocal += weightslist[1];
        i = j;
    end
    localenergy[irun,2] = elocal/wlocal;
    # E_2
    elocal = 0.0;
    wlocal = 1.0;
    wlocaltot = 0.0;
    wlocalprev = 1.0;
    j = 1;
    j = doSwap(rand(),j,pijsummed,pijidsSorted);
    wlocal *= weightij[(i,j)];
    weightslist[1] = weightij[(i,j)];
    i = j;
    j = doSwap(rand(),j,pijsummed,pijidsSorted);
    wlocal *= weightij[(i,j)];
    weightslist[2] = weightij[(i,j)];
    i = j;
    for istep in 1:nsteps
        elocal += elij[j]*wlocal;
        wlocaltot += wlocal;
        j = doSwap(rand(),j,pijsummed,pijidsSorted);
        wlocalprev = weightslist[((istep-1)%2)+1];
        wlocal = wlocal * weightij[(i,j)]/wlocalprev;
        weightslist[((istep-1)%2)+1] = weightij[(i,j)];
        i = j;
    end
    localenergy[irun,3] = elocal/wlocaltot;
end
mean(localenergy[:,1])
var(localenergy[:,1])
mean(localenergy[:,2])
var(localenergy[:,2])
mean(localenergy[:,3])
var(localenergy[:,3])
#+end_src

#+name: pdmc_algo
#+begin_src julia :tangle srdmc.jl
function do_PDMC(ham, vec0, ET, tau, nruns, niter, nsteps)
    pijsummed, pijidsSorted, elij, weightij = prepare_pij_wij(ham, vec0, ET, tau);
    localenergy = zeros(nruns, niter);
    weightlist = zeros(niter);
    prodweightlist = zeros(niter);
    #prodweightlist_per_i = zeros(niter);
    idweightlist = zeros(niter);
    for irun in 1:nruns
        # Initialize lists
        elocaltot = zeros(niter);
        wlocaltot = zeros(niter);
        j = 1;
        i = j;
        wlocal = 1.0;

        # Prepare weight list
        for it in 1:niter
            # Perform MC step
            j = doSwap(rand(),j,pijsummed,pijidsSorted);

            # Initialize weightlist
            weightlist[it] = weightij[(i,j)];

            # Save current state
            i = j;
        end

        # Prepare prodweightlist
        for it in niter:-1:1
            prodweightlist[niter-it+1] = wlocal * weightlist[it];
            wlocal = wlocal * weightlist[it];
        end

        # Do PDMC
        for istep in 1:nsteps
            # Calculate elocal and wlocal
            for it in 1:niter
               elocaltot[it] += elij[j] * prodweightlist[it];
               wlocaltot[it] += prodweightlist[it];
            end
            #if(j == 5)
            #    prodweightlist_per_i .+= prodweightlist;
            #end

            # Perform MC step
            j = doSwap(rand(),j,pijsummed,pijidsSorted);

            # Calculate new weights
            wlocal = weightij[(i,j)];
            for it in 1:niter-1
                idxdel = (((istep-1 + (niter-it)) % niter) + 1);
                #idxnew = (((istep-1 + (niter-1 )) % niter) + 1);
                #idxnew = (((istep) % niter) + 0);
                wprev = weightlist[idxdel];
                #wnew  = weightlist[idxnew];
                wnew  = wlocal;
                prodweightlist[it] = prodweightlist[it] * wnew/wprev;
            end
            idxnew = (((istep-1) % niter) + 1);
            wprev = weightlist[idxnew];
            weightlist[idxnew] = weightij[(i,j)];
            prodweightlist[niter] = prodweightlist[niter] * wlocal/wprev;

            # Save current state
            i = j;
        end

        # Fill global list
        for it in 1:niter
            localenergy[irun,it] = elocaltot[it]/wlocaltot[it];
            #localenergy[irun,it] = prodweightlist_per_i[it]/nsteps;
        end
    end
    return(localenergy);
end
#+end_src

#+name: testing
#+begin_src julia
localenergy = do_PDMC(ham, vec0, ET, tau, nruns, niter, nsteps);
println(mean(localenergy[:,1]),var(localenergy[:,1]))
println(mean(localenergy[:,2]),var(localenergy[:,2]))
println(mean(localenergy[:,3]),var(localenergy[:,3]))
#+end_src

***** Plots

#+BEGIN_SRC jupyter-julia :session j1 :results results :eval noexport :exports results #:tangle pdmc.jl
meanenerlist = zeros(niter);
varenerlist = zeros(niter);
localenergy = do_PDMC(ham, vec0, ET, tau, nruns, niter, nsteps);
for it in 1:niter
    meanenerlist[it] = mean(localenergy[:,it]);
    varenerlist[it] = var(localenergy[:,it]);
end
plt=plot(collect(1:niter),meanenerlist,
         xlabel=L"n",
         ylabel=L"E_0",
#        lw=2,
         xlims = (0,niter),
         ylims = (-2.0,-1.4),
         framestyle=:box,
         guidefontsize=10,
         legendfontsize=6,
         thickness_scaling=1.5,
         grid=:none,
#        marker=true,
#        markersize=2,
         size=(400,600),
         ribbon=varenerlist
         )
hline!([-1.97],line=:dash)
#+end_src


** Diffusion Monte Carlo

*** Algorithm

**** Code SRDMC

#+name: dmc_algo
#+begin_src julia :tangle srdmc.jl
function do_DMC(ham, vec0, ET, tau, nruns, niter, nsteps, nwalker)
    pijsummed, pijidsSorted, elij, weightij = prepare_pij_wij(ham, vec0, ET, tau);
    println(weightij);
    println(pijsummed);
    println(pijidsSorted);
    localenergy = zeros(nruns);
    walkerlisti = zeros(Int64,nwalker);
    walkerlistj = zeros(Int64,nwalker);
    newwalkerlistj = zeros(Int64,nwalker);
    weightlistscaled = zeros(Float64,nwalker);
    weightperwalker = zeros(Float64,nwalker);
    problistj = zeros(Float64,nwalker);
    nreconfmean = 0.0;
    nreconftot = 0;
    for irun in 1:nruns
        # Initialize lists
        weightlist = zeros(Float64,nwalker);
        j = 1;
        i = j;
        walkerlistj .= 1;
        walkerlisti .= 1;
        wlocal = 1.0;

        # Prepare weight list
        # Perform MC step for each walker
        for nw in 1:nwalker
            j = walkerlistj[nw];
            i = walkerlisti[nw];
            walkerlistj[nw] = doSwap(rand(),j,pijsummed,pijidsSorted);
            j = walkerlistj[nw];

            # Initialize weightlist
            weightlist[nw] = weightij[(i,j)];

            # Save current state
            walkerlisti[nw] = walkerlistj[nw];
        end

        # Do DMC
        elocaltot = 0.0;
        for istep in 1:nsteps
            # Calculate elocal and wlocal
            for nw in 1:nwalker
                elocaltot += elij[walkerlistj[nw]]/nwalker;
            end

            # Perform MC step for each walker
            for nw in 1:nwalker
                j = walkerlistj[nw];
                i = walkerlisti[nw];
                walkerlistj[nw] = doSwap(rand(),j,pijsummed,pijidsSorted);
                j = walkerlistj[nw];
                weightlist[nw] = weightij[(i,j)];

                # Save current state
                walkerlisti[nw] = walkerlistj[nw];
            end

            # Branching

            # Calculate probability list

            # Get ids of the big weights
            idbig = findall(x->x>=1.0,weightlist);
            nreconfig = length(idbig);

            totweightlist = sum(weightlist[idbig]);
            weightlistscaled = (weightlist[idbig])/totweightlist;
            problistj[1] = weightlistscaled[1];
            for nw in 2:nreconfig
                problistj[nw] = problistj[nw-1] + weightlistscaled[nw];
            end
            newwalkerlistj = branch_dmc(problistj[1:nreconfig], walkerlistj[idbig], nreconfig);
            walkerlistj[idbig] = newwalkerlistj;

            # Save j in i
            walkerlisti = walkerlistj;

        end

        # Fill global list
        localenergy[irun] = elocaltot/nsteps;
    end
    return(localenergy);
end
#+end_src

#+name: srdmc_algo
#+begin_src julia :tangle srdmc.jl
function do_SRDMC(ham, vec0, ET, tau, nruns, niter, nsteps, nwalker)
    pijsummed, pijidsSorted, elij, weightij = prepare_pij_wij(ham, vec0, ET, tau);
    println(weightij);
    println(elij);
    localenergy = zeros(nruns,niter);
    prodweightlist = zeros(niter);
    walkerlisti = zeros(Int64,nwalker);
    walkerlistj = zeros(Int64,nwalker);
    weightlistscaled = zeros(Float64,niter);
    #fullwalkerlist=zeros(Float64,6,nsteps)
    problistj = zeros(Float64,nwalker);
    for irun in 1:nruns
        # Initialize lists
        weightlist = zeros(Float64,nwalker);
        elocaltot = zeros(niter);
        wlocaltot = zeros(niter);
        j = 1;
        i = j;
        walkerlistj .= 1;
        walkerlisti .= 1;
        wlocal = 1.0;

        # Prepare weight list
        # Perform MC step for each walker
        for it in 1:niter
            for nw in 1:nwalker
                j = walkerlistj[nw];
                i = walkerlisti[nw];
                walkerlistj[nw] = doSwap(rand(),j,pijsummed,pijidsSorted);
                j = walkerlistj[nw];

                # Initialize weightlist
                weightlist[nw] = weightij[(i,j)];

                # Save current state
                walkerlisti[nw] = walkerlistj[nw];
            end
            weightlistscaled[it] = sum(weightlist)/nwalker
        end

        # Prepare prodweightlist
        for it in niter:-1:1
            prodweightlist[niter-it+1] = wlocal * weightlistscaled[it];
            wlocal = wlocal * weightlistscaled[it];
        end

        # Do DMC
        elocalavg = 0.0;
        for istep in 1:nsteps
            # Calculate elocal and wlocal
            elocalavg = 0.0;
            for nw in 1:nwalker
                elocalavg += elij[walkerlistj[nw]]/nwalker;
            end
            for it in 1:niter
                elocaltot[it] += elocalavg * prodweightlist[it];
                wlocaltot[it] += prodweightlist[it];
            end

            for nw in 1:nwalker
                j = walkerlistj[nw];
                i = walkerlisti[nw];
                walkerlistj[nw] = doSwap(rand(),j,pijsummed,pijidsSorted);
                j = walkerlistj[nw];
                weightlist[nw] = weightij[(i,j)];

                # Save current state
                walkerlisti[nw] = walkerlistj[nw];
            end

            # Calculate new weights
            wlocal = sum(weightlist)/nwalker;
            for it in 1:niter-1
                idxdel = (((istep-1 + (niter-it)) % niter) + 1);
                wprev = weightlistscaled[idxdel];
                wnew  = wlocal;
                prodweightlist[it] = prodweightlist[it] * wnew/wprev;
            end
            idxnew = (((istep-1) % niter) + 1);
            wprev = weightlistscaled[idxnew];
            weightlistscaled[idxnew] = wlocal;
            prodweightlist[niter] = prodweightlist[niter] * wlocal/wprev;

            # Branching

            # Calculate probability list
            #weightlist .= weightlist/wlocal;

            # Get ids of the big weights
            idbig = findall(x->x>=1.0,weightlist);
            nreconfig = length(idbig);

            totweightlist = sum(weightlist[idbig]);
            weightlistreconf = (weightlist[idbig])/totweightlist;
            for nw in 1:nreconfig
                problistj[nw] = sum(weightlistreconf[1:nw]);
            end
            newwalkerlistj = branch_dmc(problistj[1:nreconfig], walkerlistj[idbig], nreconfig);
            walkerlistj[idbig] = newwalkerlistj;

            # Save j in i
            walkerlisti = walkerlistj;

            #for nw in 1:nwalker
            #    fullwalkerlist[walkerlistj[nw],istep] += wlocal;
            #end

        end

        # Fill global list
        for it in 1:niter
            localenergy[irun,it] = elocaltot[it]/wlocaltot[it];
        end
    end
    return(localenergy);
end
#+end_src

**** Code Poison

***** Integrated quantities

#+name: calc_local_energy_acc
#+begin_src julia :tangle srdmc.jl
function getEL_acc(ham, vi, i)
    if(vi[i]==0.0)
        return typemax(Float64)
    else
        return ((ham*vi)[i]/vi[i])
    end
end
#+end_src

#+name: calc_local_kenergy_acc
#+begin_src julia :tangle srdmc.jl
function getKE_acc(ham, vi, i)
    return(getEL_acc(ham,vi,i) - ham[i,i])
end
#+end_src

#+name: calc_trap_time
#+begin_src julia :tangle srdmc.jl
function getTraptime_acc(ham, vi, i)
    TL = getKE_acc(ham, vi, i);
    return(-1.0/TL)
end
#+end_src

#+name: prepare_pij_list_acc
#+begin_src julia :tangle srdmc.jl
function getPij_acc(ham, tau, i, j, vec)
    pij = getPij(ham,tau,i,j,vec);
    pii = getPij(ham,tau,i,i,vec);
    return(pij/(1-pii))
end
#+end_src

#+name: getweights_acc
#+begin_src julia :tangle srdmc.jl
function getWeightij_acc(ham, tau, ET, i, j,ELi)
    if (i==j)
        TLi = ELi - ham[i,i];
        return(TLi/(ET - ham[i,i]))
    else
        return(1.0);
    end
end
#+end_src

#+name: prepare_pij_lists_with_weights_acc
#+begin_src julia :tangle srdmc.jl
function prepare_pij_wij_acc(ham, vec, ET, tau)
    dim = size(ham)[1];
    pij = SortedDict{Any, Any}[SortedDict() for i = 1:dim];
    countswaps = zeros(dim);
    elij = Dict();
    weightij = Dict();
    thetaij = Dict();
    for i in 1:dim
        for j in 1:dim
            EL = getEL_acc(ham, vec, i)
            EL1 = EL;
            θi = getTraptime_acc(ham, vec, i)
            w12 = getWeightij_acc(ham, tau, ET, i, j, EL);
            if i == j
                p12 = 0.0
            else
                p12 = getPij_acc(ham, tau, i, j, vec)
            end
            if(i==j)
                elij[i] = EL * θi;
            end
            pij[i][j] = p12;
            weightij[(i,j)] = w12
            thetaij[(i,j)] = θi;
        end
    end
    # take sum of Pij
    pijidsSorted = zeros(Int,dim,dim);
    pijsummed = SortedDict{Any, Any}[SortedDict() for i = 1:dim];
    for i in 1:dim
        map(x->pijsummed[i][collect(keys(pij[i]))[x]]=foldl(+,collect(values(pij[i]))[1:x]),1:length(pij[i]))
        pijidsSorted[i,1:dim] = collect(keys(pijsummed[i]))
    end
    return(pijsummed,pijidsSorted, elij, weightij,thetaij)
end
#+end_src

#+name: swap_states
#+begin_src julia :tangle srdmc.jl
function doSwap_acc(randval, j, pij, pijids)
   return(pijids[j,searchsortedfirst(collect(values(pij[j])),randval)])
end
#+end_src

***** SRDMC poisson algo

#+name: srdmc_algo_acc2
#+begin_src julia :tangle srdmc.jl
function do_SRDMC_acc2(ham, vec0, ET, tau, nruns, niter, nsteps, nwalker)
    pijsummed, pijidsSorted, elij, weightij, thetaij = prepare_pij_wij_acc(ham, vec0, ET, tau);
    println(weightij);
    println(elij);
    localenergy = zeros(nruns,niter);
    prodweightlist = zeros(niter);
    walkerlisti = zeros(Int64,nwalker);
    walkerlistj = zeros(Int64,nwalker);
    weightlistscaled = zeros(Float64,niter);
    #fullwalkerlist=zeros(Float64,6,nsteps)
    problistj = zeros(Float64,nwalker);
    for irun in 1:nruns
        # Initialize lists
        weightlist = zeros(Float64,nwalker);
        elocaltot = zeros(niter);
        wlocaltot = zeros(niter);
        j = 1;
        i = j;
        walkerlistj .= 1;
        walkerlisti .= 1;
        wlocal = 1.0;

        # Prepare weight list
        # Perform MC step for each walker
        for it in 1:niter
            for nw in 1:nwalker
                j = walkerlistj[nw];
                i = walkerlisti[nw];
                walkerlistj[nw] = doSwap_acc(rand(),j,pijsummed,pijidsSorted);
                j = walkerlistj[nw];

                # Initialize weightlist
                weightlist[nw] = weightij[(j,j)];

                # Save current state
                walkerlisti[nw] = walkerlistj[nw];
            end
            weightlistscaled[it] = sum(weightlist)/nwalker
        end

        # Prepare prodweightlist
        for it in niter:-1:1
            prodweightlist[niter-it+1] = wlocal * weightlistscaled[it];
            wlocal = wlocal * weightlistscaled[it];
        end

        # Do DMC
        elocalavg = 0.0;
        for istep in 1:nsteps
            # Calculate elocal and wlocal
            elocalavg = 0.0;
            thetaavg = 0.0;
            for nw in 1:nwalker
                jnw = walkerlistj[nw];
                elocalavg += elij[jnw] * thetaij[(jnw,jnw)]/nwalker;
                thetaavg += thetaij[(jnw,jnw)]/nwalker;
            end
            for it in 1:niter
                elocaltot[it] += elocalavg * prodweightlist[it];
                wlocaltot[it] += prodweightlist[it] * thetaavg;
            end

            for nw in 1:nwalker
                j = walkerlistj[nw];
                i = walkerlisti[nw];
                walkerlistj[nw] = doSwap_acc(rand(),j,pijsummed,pijidsSorted);
                j = walkerlistj[nw];
                weightlist[nw] = weightij[(j,j)];

                # Save current state
                walkerlisti[nw] = walkerlistj[nw];
            end

            # Calculate new weights
            wlocal = sum(weightlist)/nwalker;
            for it in 1:niter-1
                idxdel = (((istep-1 + (niter-it)) % niter) + 1);
                wprev = weightlistscaled[idxdel];
                wnew  = wlocal;
                prodweightlist[it] = prodweightlist[it] * wnew/wprev;
            end
            idxnew = (((istep-1) % niter) + 1);
            wprev = weightlistscaled[idxnew];
            weightlistscaled[idxnew] = wlocal;
            prodweightlist[niter] = prodweightlist[niter] * wlocal/wprev;

            # Branching

            # Calculate probability list
            #weightlist .= weightlist/wlocal;

            # Get ids of the big weights
            idbig = findall(x->x>=1.0,weightlist);
            nreconfig = length(idbig);

            totweightlist = sum(weightlist[idbig]);
            weightlistreconf = (weightlist[idbig])/totweightlist;
            for nw in 1:nreconfig
                problistj[nw] = sum(weightlistreconf[1:nw]);
            end
            newwalkerlistj = branch_dmc(problistj[1:nreconfig], walkerlistj[idbig], nreconfig);
            walkerlistj[idbig] = newwalkerlistj;

            # Save j in i
            walkerlisti = walkerlistj;

            #for nw in 1:nwalker
            #    fullwalkerlist[walkerlistj[nw],istep] += wlocal;
            #end

        end

        # Fill global list
        for it in 1:niter
            localenergy[irun,it] = elocaltot[it]/wlocaltot[it];
        end
    end
    return(localenergy);
end
#+end_src

#+name: pdmc_algo_acc
#+begin_src julia :tangle srdmc.jl
function do_PDMC_acc(ham, vec0, ET, tau, nruns, niter, nsteps)
    pijsummed, pijidsSorted, elij, weightij, thetaij = prepare_pij_wij_acc(ham, vec0, ET, tau);
    localenergy = zeros(nruns, niter);
    weightlist = zeros(niter);
    prodweightlist = zeros(niter);
    #prodweightlist_per_i = zeros(niter);
    idweightlist = zeros(niter);
    for irun in 1:nruns
        # Initialize lists
        elocaltot = zeros(niter);
        wlocaltot = zeros(niter);
        j = 1;
        i = j;
        wlocal = 1.0;

        # Prepare weight list
        for it in 1:niter
            # Perform MC step
            j = doSwap_acc(rand(),j,pijsummed,pijidsSorted);

            # Initialize weightlist
            weightlist[it] = weightij[(j,j)];

            # Save current state
            i = j;
        end

        # Prepare prodweightlist
        for it in niter:-1:1
            prodweightlist[niter-it+1] = wlocal * weightlist[it];
            wlocal = wlocal * weightlist[it];
        end

        # Do PDMC
        for istep in 1:nsteps
            # Calculate elocal and wlocal
            for it in 1:niter
               elocaltot[it] += elij[j] * prodweightlist[it] * thetaij[(j,j)];
               wlocaltot[it] += prodweightlist[it] * thetaij[(j,j)];
            end
            #if(j == 5)
            #    prodweightlist_per_i .+= prodweightlist;
            #end

            # Perform MC step
            jnew = doSwap_acc(rand(),j,pijsummed,pijidsSorted);
            j = jnew;

            # Calculate new weights
            wlocal = weightij[(j,j)];
            for it in 1:niter-1
                idxdel = (((istep-1 + (niter-it)) % niter) + 1);
                #idxnew = (((istep-1 + (niter-1 )) % niter) + 1);
                #idxnew = (((istep) % niter) + 0);
                wprev = weightlist[idxdel];
                #wnew  = weightlist[idxnew];
                wnew  = wlocal;
                prodweightlist[it] = prodweightlist[it] * wnew/wprev;
            end
            idxnew = (((istep-1) % niter) + 1);
            wprev = weightlist[idxnew];
            weightlist[idxnew] = wlocal;
            prodweightlist[niter] = prodweightlist[niter] * wlocal/wprev;

            # Save current state
            i = j;
        end

        # Fill global list
        for it in 1:niter
            localenergy[irun,it] = elocaltot[it]/wlocaltot[it];
            #localenergy[irun,it] = prodweightlist_per_i[it]/nsteps;
        end
    end
    return(localenergy);
end
#+end_src

#+name: branching
#+begin_src julia :tangle srdmc.jl
function branch_dmc(problist,   walkerlist,nwalker)
    # Make new walker list
    newwalkerlist = zeros(Int64,nwalker);
    for nw in 1:nwalker
        newwalkerlist[nw] = walkerlist[searchsortedfirst(problist, rand())];
    end
    return(newwalkerlist);
end
#+end_src

***** Plots

#+BEGIN_SRC jupyter-julia :session j1 :results results :eval noexport :exports results #:tangle pdmc.jl
niter2 = Int32(niter/2);
meanenerlist = zeros(niter2,2);
varenerlist = zeros(niter2,2);
localenergypdmc = do_PDMC(ham, vec0, ET, tau, nruns, niter, nsteps);
localenergy = do_PDMC_acc(ham, vec0, ET, tau, nruns, niter, nsteps);
idx=1
for it in 1:2:niter-1
    meanenerlist[idx,1] = (mean(localenergy[:,it])+mean(localenergy[:,it+1]))/2;
    varenerlist[idx,1] = (var(localenergy[:,it])+var(localenergy[:,it+1]))/2;
    meanenerlist[idx,2] = mean(localenergypdmc[:,it]);
    varenerlist[idx,2] = var(localenergypdmc[:,it]);
    idx +=1;
end
plt=plot(collect(1:niter2),meanenerlist,
         xlabel=L"n",
         ylabel=L"E_0",
#        lw=2,
         xlims = (0,niter2),
#        ylims = (0.38,0.4),
         framestyle=:box,
         guidefontsize=10,
         legend=false,
#        legendfontsize=6,
         thickness_scaling=1.5,
         grid=:none,
#        marker=true,
#        markersize=2,
         size=(400,600),
         ribbon=varenerlist,
         label=["SRDMC" "PDMCacc" ""]
         )
hline!([-0.79],line=:dash,label=nothing)
hline!([-0.21432],line=:dash,label=nothing)
hline!([0.381966],line=:dash,label=nothing)
hline!([-2.366],line=:dash,label=nothing)
figpath="/tmp/";
savefig(plt,figpath*"fig1.pdf")
#+end_src


** FCIQMC

*** Initialize
#+name: var3x3
#+begin_src julia
using Plots
using LaTeXStrings
using DataStructures
using Statistics
using LinearAlgebra
using Profile
using Revise
using DelimitedFiles

includet("srdmc.jl")
# Vars
nu0 = 0;
nu1 = 1;
nu2 = 2;
ζ=0.5;
stepsize = 5;
t=1;
# Trial energy
ET = 0.01;
# Taux d'acceptation > 99%
tau = 0.05;
c0= 1.001/sqrt(3);
c1= 0.90001/sqrt(3);
c2= 0.80/sqrt(3);
nsteps = 750;
nruns = 4;
nwalkermax = 10^7;
ham=[nu0  t -t;  t nu1 -t; -t -t nu2]*1.0;
vec0 = [c0, c1, c2];
vec0 = vec0/norm(vec0);
e_exact,vec_exact = eigen(ham)
#+end_src

#+name: var6x6
#+begin_src julia
using Plots
using LaTeXStrings
using DataStructures
using Statistics
using LinearAlgebra
using Profile
using Revise
using DelimitedFiles

includet("srdmc.jl")
# Vars
t=1;
# Trial energy
ET = 0.01;
ζ=0.5;
tau = 0.20;
stepsize = 5;
nu0 = 1+0;
nu1 = 2+0;
nu2 = 3+0;
nu3 = 4+0;
nu4 = 5+0;
nu5 = 6+0;
# Taux d'acceptation > 99%
ham=[nu0  t   -t   0   0    0;
      t   nu1 -t  -t  -t   -t;
     -t   -t  nu2 -t  -t   -t;
      0   -t  -t  nu3 -t   -t;
      0   -t  -t  -t  nu4  -t;
      0   -t  -t  -t  -t  nu5;]*1.0;
nsteps = 2;#750;
nruns = 1;
nwalkermax = 10^7;
e_exact,vec_exact = eigen(ham)
#+end_src

*** Description


*** Algorithm

**** Code

***** FCIQMC quantities

#+name: calc_local_energy_fciqmc
#+begin_src julia :tangle srdmc.jl
function getEL_fciqmc(ham, vi, i)
    if(vi[i]==0.0)
        return typemax(Float64)
    else
        return ((ham*vi)[i]/vi[i])
    end
end
#+end_src

#+name: getPdiagi_fciqmc
#+begin_src julia :tangle srdmc.jl
function getPdiagi_fciqmc(ham, tau, i, ET)
    numer = tau * (ham[i,i]-ET);
    return(numer)
end
#+end_src

#+name: getPij_fciqmc
#+begin_src julia :tangle srdmc.jl
function getPij_fciqmc(ham, tau, i, j, vec)
    dim = size(ham)[1];
    numer = abs(ham[i,j]);
    denom = 0.0;
    for k in 1:dim
        if (k!=i)
            denom = denom + abs(ham[i,k]);
        end
    end
    if(denom==0.0)
        return typemax(Float64)
    else
        return(numer/denom)
    end
end
#+end_src

#+name: getspawnij_list_fciqmc
#+begin_src julia :tangle srdmc.jl
function getspawnij_fciqmc(ham, tau, i, j, vec, sgni)
    if ham[i,j] < 0.0
        sgnj =  1.0 * sgni;
    else
        sgnj = -1.0 * sgni;
    end
    numer = tau * abs(ham[i,j]);
    denom = getPij_fciqmc(ham,tau,i,j,vec);
    if(denom==0.0)
        return (typemax(Float64),sgnj)
    else
        return((numer/denom),sgnj)
    end
end
#+end_src

#+name: adjustS_states_fciqmc
#+begin_src julia :tangle srdmc.jl
function adjustS_fciqmc(Sold,ζ,tau,Nw,Nwold,stepsize)
    if Nw == 0
        return(Sold + 0.0001)
    end
    Snew = Sold - log(Nw/Nwold) * ζ / (stepsize * tau);
    return(Snew)
end
#+end_src

#+name: swap_states_fciqmc
#+begin_src julia :tangle srdmc.jl
function doSwap_fciqmc(randval, j, pij, pijids)
   return(pijids[j,searchsortedfirst(collect(values(pij[j])),randval)])
end
#+end_src

#+name: prepare_pij_lists_with_weights_fciqmc
#+begin_src julia :tangle srdmc.jl
function prepare_psij_pdi_fciqmc(ham, vec, ET, tau)
    dim = size(ham)[1];
    pij = SortedDict{Any, Any}[SortedDict() for i = 1:dim];
    countswaps = zeros(dim);
    for i in 1:dim
        for j in 1:dim
            if i == j
                p12 = 0.0
            else
                p12 = getPij_fciqmc(ham, tau, i, j, vec)
            end
            pij[i][j] = p12;
        end
    end
    # take sum of Pij
    pijidsSorted = zeros(Int,dim,dim);
    pijsummed = SortedDict{Any, Any}[SortedDict() for i = 1:dim];
    for i in 1:dim
        map(x->pijsummed[i][collect(keys(pij[i]))[x]]=foldl(+,collect(values(pij[i]))[1:x]),1:length(pij[i]))
        pijidsSorted[i,1:dim] = collect(keys(pijsummed[i]))
    end
    return(pijsummed,pijidsSorted)
end
#+end_src

***** FCIQMC algo

#+name: pdmc_algo_fciqmc
#+begin_src julia :tangle srdmc.jl
function do_FCIQMC(ham, vec0, ET, tau, stepsize, ζ, nruns, nsteps, nwalkermax)
    pijsummed, pijidsSorted = prepare_psij_pdi_fciqmc(ham, vec0, ET, tau);
    println(pijsummed);
    println(pijidsSorted);
    dimH = size(ham)[1];
    localenergy = zeros(nruns);
    totalwalkerlist = zeros(nsteps);
    etlist = zeros(nsteps);
    walkerlisti = zeros(nwalkermax);
    walkerlistj = zeros(nwalkermax);
    walkerlistmerge = zeros(nwalkermax);
    walkersigni = zeros(nwalkermax);
    walkersignj = zeros(nwalkermax);
    walkersignmerge = zeros(nwalkermax);
    numlist = zeros(Int32,dimH);
    sgnwalkers = zeros(Int32,dimH);
    ETsave = ET;
    for irun in 1:nruns
        # Initialize lists
        elocaltot = 0.0;
        j = 1;
        i = j;
        nwalker = 0;
        nwalkerold = 1;
        nwspawn = 0;
        walkerlisti[nwalkerold] = i;
        walkersigni[nwalkerold] = 1.0;
        doStep = false;
        ET = ETsave;

        # Do PDMC
        for istep in 1:nsteps

            Nwold = nwalkerold;

            # Step 1 - Spawning

            for nw in 1:nwalkerold
                i = Int32(walkerlisti[nw]);
                sgni = walkersigni[nw];
                jnew = doSwap_fciqmc(rand(),i,pijsummed,pijidsSorted);
                pspawnj, sgnj = getspawnij_fciqmc(ham, tau, i, jnew, vec0, sgni);
                if 1.0 > pspawnj > 0.0
                    if pspawnj > rand() || nwalkerold == 1
                        nwalker = nwalker + 1;
                        walkerlistj[nwalker] = jnew;
                        walkersignj[nwalker] = sgnj;
                    end
                elseif pspawnj > 1.0
                    walkerlistj[nwalker+1:nwalker+floor(Int32,pspawnj)] .= jnew;
                    walkersignj[nwalker+1:nwalker+floor(Int32,pspawnj)] .= sgnj;
                    nwalker = nwalker + floor(Int32,pspawnj);
                    if (pspawnj-floor(Int32,pspawnj)) > rand()
                        nwalker = nwalker + 1;
                        walkerlistj[nwalker] = jnew;
                        walkersignj[nwalker] = sgnj;
                    end
                end
            end

            nwspawn = nwalker;

            #println("new walkers\n",nwalker,"\t",walkerlistj[1:nwalker]);

            # Step 2 - Death/Cloning

            for nw in 1:nwalkerold
                i = Int32(walkerlisti[nw]);
                sgni = walkersigni[nw];
                pdiei = getPdiagi_fciqmc(ham, tau, i, ET);
                if pdiei > 0
                    if rand() < pdiei
                        walkerlisti[nw] *= -1;
                    end
                else
                    if rand() < abs(pdiei)
                        nwalker = nwalker + 1;
                        walkerlistj[nwalker] = i;
                        walkersignj[nwalker] = sgni;
                    end
                end
            end

            #println("\n cloned ",nwalker,"\t",walkerlistj[1:nwalker],"\n sign ",walkersignj[1:nwalker]);

            # Prune the dead walkers

            walkerlisti_nodead = walkerlisti[findall(x->x>0,walkerlisti[1:nwalkerold])];
            walkersigni_nodead = walkersigni[findall(x->x>0,walkerlisti[1:nwalkerold])];
            nwalkerold = size(walkerlisti_nodead)[1];

            #println("\n no dead ",nwalkerold," \t ",walkerlisti_nodead);

            # Step 3 - Annahilation and merging

            #  SubStep 1 - make signed list

            walkerlisti_tmp = copy(walkerlisti_nodead[1:nwalkerold] .* walkersigni_nodead[1:nwalkerold]);
            walkerlistj_tmp = copy(walkerlistj[1:nwalker] .* walkersignj[1:nwalker]);

            #println("\n tmpi ",walkerlisti_tmp);
            #println("\n tmpj ",walkerlistj_tmp);

            #  SubStep 2 - merge new and old list

            mergewalkerlist = vcat((walkerlisti_tmp,walkerlistj_tmp)...);

            #  SubStep 3 - Find unique walkers
            uniquewalkers = unique(abs.(mergewalkerlist));
            #println("mergelist\n",mergewalkerlist);
            #println("unique\n",uniquewalkers);

            nwalkerold = 0;
            for nwi in uniquewalkers
                Nposi = size(findall(x->x==nwi,mergewalkerlist))[1];
                Nnegi = size(findall(x->x==-nwi,mergewalkerlist))[1];
                sgni = Nposi - Nnegi;
                if sgni > 0
                    nnew = abs(sgni);
                    #println("nwi -- ",nwi," -- ",Nposi,"\t",Nnegi," --  sgni ",sgni);
                    sgni = sgni/nnew;
                    walkerlisti[nwalkerold+1:nwalkerold+nnew] .= nwi;
                    walkersigni[nwalkerold+1:nwalkerold+nnew] .= sgni;
                    nwalkerold = nwalkerold + nnew;
                end
                sgnwalkers[Int32(nwi)] = sgni;
            end

            #println("new num \n",nwalkerold);
            #println("new walkers \n",walkerlisti[1:nwalkerold]);
            #println("new walkers sign \n",walkersigni[1:nwalkerold]);

            Nw = nwalkerold;

            # Step 4 - Change ET

            if nwalkerold > 1000
                doStep = true
            end
            if istep % stepsize == 0 && doStep
                # Change ET
                if istep % (stepsize * 10) == 0
                    println("istep = ",istep, " Nw = ",nwspawn," Nwold = ",Nwold," ET = ",ET," ζ= ",ζ," stepsize= ",stepsize," tau= ",tau);
                end
                ET = adjustS_fciqmc(ET,ζ,tau,Nw,Nwold,stepsize);
                pijsummed, pijidsSorted = prepare_psij_pdi_fciqmc(ham, vec0, ET, tau);
            end

            totalwalkerlist[istep] = nwalkerold;
            etlist[istep] = ET;

            nwalker = 0;

        end

        # Fill global list
        #localenergy[irun] = ET;

        println(" ---- DONE ---- ",irun," ", nwalkerold,"\n");
        totnum = 0;
        for ni in 1:dimH
            numlist[ni] = size(findall(x->abs(abs(x)-ni*1.0) < 1e-4,walkerlisti[1:nwalkerold]))[1];
            totnum = totnum + numlist[ni];
            println(ni," - ",numlist[ni]," - ",sgnwalkers[ni]);
        end
        localenergy[irun] = ET;
    end
    return(localenergy, totalwalkerlist, etlist);
end
#+end_src

***** Plots

#+BEGIN_SRC jupyter-julia :session j1 :results results :eval noexport :exports results #:tangle pdmc.jl
tau = 0.21;
nsteps=10;
localenergy, totalwalkerlist, etlist = do_FCIQMC(ham, vec0, ET, tau, stepsize, ζ, nruns, nsteps, nwalkermax);
meanenerlist = mean(localenergy)
varenerlist = var(localenergy)
plt=plot(collect(1:nsteps),etlist,
         xlabel=L"n",
         ylabel=L"E_0",
#        lw=2,
         xlims = (0,nsteps),
#        ylims = (0.38,0.4),
         framestyle=:box,
         guidefontsize=10,
         legend=false,
#        legendfontsize=6,
         thickness_scaling=1.5,
         grid=:none,
#        marker=true,
#        markersize=2,
         size=(400,600),
#        ribbon=varenerlist,
         label=["SRDMC" "PDMCacc" ""]
         )
hline!([-0.41],line=:dash,label=nothing)
hline!([-0.21432],line=:dash,label=nothing)
hline!([0.381966],line=:dash,label=nothing)
hline!([-2.366],line=:dash,label=nothing)
figpath="/tmp/";
savefig(plt,figpath*"fig1.pdf")
#+end_src

* Testing

#+begin_src julia :results output
tmpnmax = 16
tmparray = zeros(tmpnmax);
map(x->tmparray[x]=x,collect(1:tmpnmax));
for i in 1:tmpnmax
    idx8 = (((i-1)%8)+1)
    idx5 = (((i-1 + 3)%8)+1)
    idx4 = (((i-1 + 4)%8)+1)
    idx3 = (((i-1 + 5)%8)+1)
    println(idx8,"\t",tmparray[idx8])
    println("\t---",idx5, "\t---",idx4, "\t---",idx3)
    idx5 = (((i-1 + 3 + 5 - 1)%8)+1)
    idx4 = (((i-1 + 4 + 4 - 1)%8)+1)
    idx3 = (((i-1 + 5 + 3 - 1)%8)+1)
    println("\t---",idx5, "\t---",idx4, "\t---",idx3)
end
#+end_src

#+RESULTS:

--------    --------    --------    --------
12345678    12345678    12345678    12345678
***-----    ****----    *****---    ******--
   12345        1234         123          12

--------    --------    --------    --------
12345678    12345678    12345678    12345678
-***----    -****---    -*****--    -******-
5   1234    4    123    3     12    2      1

--------    --------    --------    --------
12345678    12345678    12345678    12345678
--***---    --****--    --*****-    --******
45   123    34    12    23     1    12

#+begin_src julia
val = 2;
prob = rand();
while val > prob
    println(prob);
    val = 0.5;
    prob = rand();
end
#+end_src
