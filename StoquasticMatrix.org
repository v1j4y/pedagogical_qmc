# -*- mode:org -*-
#+TITLE: QMC Part I
#+AUTHOR: Vijay Gopal Chilkuri
#+EMAIL: vijay.gopal.c@gmail.com
#+OPTIONS: toc:t
#+LATEX_CLASS: article
#+LATEX_HEADER: \usepackage{tabularx}

* Part I

* Simple power method

** 2x2 Matrix

Consider a Hamiltonian whose matrix form is shown in Eq:[[mat2x2]]. This Hamiltonian
has two eigenvectors and two eigenvalues. Let the two eigenvectors be
\(\mathbf{u_0}\) and \(\mathbf{u_1}\). Then consider \(\mathbf{\nu}\) any arbitrary trial vector which is
not an eigenvector of Eq:[[mat2x2]] but belongs to the 2x2 space. Any such trial vector
can always be written in the form shown in Eq:[[vecbasis]].

#+NAME: mat2x2
#+ATTR_LATEX: :mode math :environment bmatrix :align cc
#+tblname: mat2x2
| v_0 | -t  |
| -t  | v_1 |

#+NAME: vecbasis
\begin{equation}
\mathbf{\nu} = c_0 \mathbf{u_0} + c_1 \mathbf{u_1}
\end{equation}

The key idea is the realization that the ground state of the Hamiltonian [[mat2x2]]
given by \(\mathbf{u_0}\) can be extracted from \(\mathbf{\nu}\) by the repeated
application of a filter \( G(H) \). This filter systematically purifies
\(\mathbf{\nu}\) to obtain the ground state \(\mathbf{u_0}\) provided \(c_0 > 0\),
i.e. the trial vector \(\mathbf{\nu}\) has a non-zero projection on the
ground state.

The form of the filter is inspired from the power method where a successive
application of the Hamiltonian followed by the substraction of the residual
leads to a convergent series of vectors. The limiting value of this convergent
series is one of the extremal eigenvectors of the Hamiltonian. Following this, our filter \(G(H)\) can be written as [[filter]]

#+NAME: filter
\begin{equation}
\hat{G}(H) = \left ( \mathbf{1} - \tau (\hat{H} - E_T\mathbf{1}) \right)
\end{equation}

The convergent series of vectors is then \(\left\{ \nu^{(0)},  \nu^{(1)},\
\nu^{(2)},\dots,\nu^{(n)}\right\}\) where \(\nu^{(k)}\) is given by [[applyg]]

#+NAME: applyg
\begin{equation}
\nu^{(k+1)} = \hat{G}(H)\nu^{(k)}
\end{equation}

Using Eq:[[vecbasis]], Eq:[[applyg]] can be written as [[applyg2]]

#+NAME: applyg2
\begin{equation}
\nu^{(k+1)} = c_0 (1-\tau(E_0-E_T))^{(k)}\mathbf{u_0} + c_1 (1-\tau(E_1-E_T))^{(k)}\mathbf{u_1}
\end{equation}

From Eq:[[applyg2]], we can see that a repeated application of the filter Eq:[[filter]]
with a trial guess energy \(E_T\) will result in the series converging
geometrically to either \(E_0\) or \(E_1\) depending on the choice of \(E_T\).

Here we shall show an example using the Hamiltonian given in Eq:[[mat2x2]]. In the
case of a 2x2 Hamiltonian, and any general trial vector \([c_0,c_1]\), the
recursion relations for the calculation of \(c^{(k)}_0\) and \(c^{(k)}_1\) are
straight forward and given by Eq:[[receqn1]],[[receqn2]].

#+NAME: receqn1
\begin{equation}
c^{(k+1)}_0 =  \left(\mathbf{1}-\tau\left(\nu_0 - E_T\right)\right)c^{(k)}_0 + \tau t c^{(k)}_1
\end{equation}

#+NAME: receqn2
\begin{equation}
c^{(k+1)}_1 = \tau t c^{(k)}_0 + \left(\mathbf{1}-\tau\left(\nu_1 - E_T\right)\right)c^{(k)}_1
\end{equation}

These are the working equations. As an example, we begin with the initial set of
values given as follows:

#+BEGIN_SRC jupyter-julia :session j1 :results output :exports results
nu0 = 1;
nu1 = 2;
t=1;
tau = 0.1;
ET = 3;
c0=1/sqrt(10);
c1=3/sqrt(10);
ham=[nu0 -t; -t nu1];
println("\\nu_0=",nu0)
println("\\nu_1=",nu1)
println("t=",t)
println("\\tau=",tau)
println("E_T=",ET)
println("c_0=",c0)
println("c_1=",c1)
#+END_SRC

#+ATTR_LATEX: :mode math

The iteration can begin with these as starting values. The output is given in
shown in the Figure:[[figure1]].

#+BEGIN_SRC jupyter-julia :session j1 :results results :eval noexport :exports results
using Plots
using Plots.PlotMeasures
using LaTeXStrings
#println("| El |\t");
#println("+----+\t");
outputdata=[];
for n in 10:10:80
    ck0=c0;
    ck1=c1;
    for i in 1:n
        tck0=ck0;
        tck1=ck1;
        ck0 = (1-tau*(nu0 - ET))tck0 + t*tau*tck1;
        ck1 = tau*t*tck0 + (1-tau*(nu1-ET))*tck1;
        norm = sqrt(ck0*ck0 + ck1*ck1);
        ck0=ck0/norm;
        ck1=ck1/norm;
    end
    energy = [ck0 ck1] * (ham*[ck0;ck1]);
    energy = (ham*[ck0;ck1])[1]/ck0;
#   println(n,"\t",ck0,"\t",ck1,"\t",energy[1]);
#   println("| ",energy[1]," |");
#   println(energy[1]);
    push!(outputdata,energy[1])
end
savefig(
    plot(1:length(outputdata),outputdata,
         xlabel=L"n",
         ylabel=L"E_0",
         lw=2,
         xlims = (0,9),
         ylims = (0.32,0.42),
         framestyle=:box,
         guidefontsize=10,
         legendfontsize=6,
         thickness_scaling=1.5,
         grid=:none,
         marker=true,
         markersize=2
         )
    ,"/home/vijay/Documents/pedagogical_qmc/figure1.pdf");
#return(outputdata)
#+END_SRC

#+CAPTION: Convergence of the Local energy as a function of iterations.
#+ATTR_LATEX: :width 15cm
#+NAME: figure1
[[/home/vijay/Documents/pedagogical_qmc/figure1.pdf]]

** 3x3 Matrix

A demonstration of all the different variants of QMC requires more than two states. Here we show a Hamiltonian with 3 states. The matrix form of the Hamiltonian is shown in Eq:[[mat3x3]].

#+NAME: mat3x3
#+ATTR_LATEX: :mode math :environment bmatrix :align cc
| v_0 | -t  | -t  |
| -t  | v_1 | -t  |
| -t  | -t  | v_2 |

The trial vector can be written as shown in Eq:[[trial3x3]].

#+NAME: trial3x3
\begin{equation}
\nu = c_0\mathbf{u}_0 + c_1\mathbf{u}_1 + c_2\mathbf{u}_2
\end{equation}

The three coefficients required are \(c_0\), \(c_1\), and \(c_2\). The recurrence relations for
the three coefficients shown in Eq:[[applyg3x3]], Eq:[[receqn3]], Eq:[[receqn4]], and Eq:[[receqn5]].

#+NAME: applyg3x3
\begin{equation}
\nu^{(k+1)} = c_0 (1-\tau(E_0-E_T))^{(k)}\mathbf{u_0} + c_1 (1-\tau(E_1-E_T))^{(k)}\mathbf{u_1}
\end{equation}

#+NAME: receqn3
\begin{equation}
c^{(k+1)}_0 =  \left(\mathbf{1}-\tau\left(\nu_0 - E_T\right)\right)c^{(k)}_0 + \tau t c^{(k)}_1 + \tau t c^{(k)}_2
\end{equation}

#+NAME: receqn4
\begin{equation}
c^{(k+1)}_1 = \tau t c^{(k)}_0 + \left(\mathbf{1}-\tau\left(\nu_1 - E_T\right)\right)c^{(k)}_1 + \tau t c^{(k)}_2
\end{equation}

#+NAME: receqn5
\begin{equation}
c^{(k+1)}_2 = \tau t c^{(k)}_0 + \tau t c^{(k)}_1 + \left(\mathbf{1}-\tau\left(\nu_2 - E_T\right)\right)c^{(k)}_2
\end{equation}

#+BEGIN_SRC jupyter-julia :session j1 :results output :exports results
nu0 = 1;
nu1 = 2;
nu2 = 3;
t=1;
tau = 0.05;
ET = 3;
c0= 1/sqrt(6);
c1=-2/sqrt(6);
c2= 1/sqrt(6);
ham=[nu0 -t -t; -t nu1 -t; -t -t nu2];
println("\\nu_0=",nu0)
println("\\nu_1=",nu1)
println("\\nu_2=",nu2)
println("t=",t)
println("\\tau=",tau)
println("E_T=",ET)
println("c_0=",c0)
println("c_1=",c1)
println("c_1=",c2)
#+END_SRC

#+RESULTS:
#+begin_example
\nu_0=1
\nu_1=2
\nu_2=3
t=1
\tau=0.05
E_T=3
c_0=0.4082482904638631
c_1=-0.8164965809277261
c_1=0.4082482904638631
#+end_example

#+ATTR_LATEX: :mode math

The iteration can begin with these as starting values. The output is given in
shown in the Figure:[[figure2]].

#+BEGIN_SRC jupyter-julia :session j1 :results results :eval noexport :exports results
using Plots
using Plots.PlotMeasures
using LaTeXStrings
#println("| El |\t");
#println("+----+\t");
outputdata=[];
for n in 10:10:80
    ck0=c0;
    ck1=c1;
    ck2=c2;
    for i in 1:n
        tck0=ck0;
        tck1=ck1;
        tck2=ck2;
        ck0 = (1-tau*(nu0-ET))*tck0 + t*tau*tck1 + t*tau*tck2;
        ck1 = tau*t*tck0 + (1-tau*(nu1-ET))*tck1 + t*tau*tck2;
        ck2 = tau*t*tck0 + tau*t*tck1 + (1-tau*(nu2-ET))*tck2;
        norm = sqrt(ck0*ck0 + ck1*ck1 + ck2*ck2);
        ck0=ck0/norm;
        ck1=ck1/norm;
        ck2=ck1/norm;
    end
    energy = [ck0 ck1 ck2] * (ham*[ck0;ck1;ck2]);
    energy = (ham*[ck0;ck1;ck2])[1]/ck0;
#   println(n,"\t",ck0,"\t",ck1,"\t",energy[1]);
#   println("| ",energy[1]," |");
#   println(energy[1]);
    push!(outputdata,energy[1])
end
savefig(
    plot(1:length(outputdata),outputdata,
         xlabel=L"n",
         ylabel=L"E_0",
         lw=2,
         xlims = (0,9),
         ylims = (-1.80, 0.50),
         framestyle=:box,
         guidefontsize=10,
         legendfontsize=6,
         thickness_scaling=1.5,
         grid=:none,
         marker=true,
         markersize=2
         )
    ,"/home/vijay/Documents/pedagogical_qmc/figure2.pdf");
#return(outputdata)
#+END_SRC


#+CAPTION: Convergence of the Local energy as a function of iterations.
#+ATTR_LATEX: :width 15cm
#+NAME: figure2
[[/home/vijay/Documents/pedagogical_qmc/figure2.pdf]]
