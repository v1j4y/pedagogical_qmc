# -*- mode:org -*-
#+TITLE: QMC Part I
#+AUTHOR: Vijay Gopal Chilkuri
#+EMAIL: vijay.gopal.c@gmail.com
#+OPTIONS: toc:t
#+LATEX_CLASS: article
#+LATEX_HEADER: \usepackage{tabularx}

* Part I

* Simple power method

** 2x2 Matrix

Consider a Hamiltonian whose matrix form is shown in Eq:[[mat2x2]]. This Hamiltonian
has two eigenvectors and two eigenvalues. Let the two eigenvectors be
\(\mathbf{u_0}\) and \(\mathbf{u_1}\). Then consider \(\mathbf{\nu}\) any arbitrary trial vector which is
not an eigenvector of Eq:[[mat2x2]] but belongs to the 2x2 space. Any such trial vector
can always be written in the form shown in Eq:[[vecbasis]].

#+NAME: mat2x2
#+ATTR_LATEX: :mode math :environment bmatrix :align cc
#+tblname: mat2x2
| v_0 | -t  |
| -t  | v_1 |

#+NAME: vecbasis
\begin{equation}
\mathbf{\nu} = c_0 \mathbf{u_0} + c_1 \mathbf{u_1}
\end{equation}

The key idea is the realization that the ground state of the Hamiltonian [[mat2x2]]
given by \(\mathbf{u_0}\) can be extracted from \(\mathbf{\nu}\) by the repeated
application of a filter \( G(H) \). This filter systematically purifies
\(\mathbf{\nu}\) to obtain the ground state \(\mathbf{u_0}\) provided \(c_0 > 0\),
i.e. the trial vector \(\mathbf{\nu}\) has a non-zero projection on the
ground state.

The form of the filter is inspired from the power method where a successive
application of the Hamiltonian followed by the substraction of the residual
leads to a convergent series of vectors. The limiting value of this convergent
series is one of the extremal eigenvectors of the Hamiltonian. Following this, our filter \(G(H)\) can be written as [[filter]]

#+NAME: filter
\begin{equation}
\hat{G}(H) = \left ( \mathbf{1} - \tau (\hat{H} - E_T\mathbf{1}) \right)
\end{equation}

The convergent series of vectors is then \(\left\{ \nu^{(0)},  \nu^{(1)},\
\nu^{(2)},\dots,\nu^{(n)}\right\}\) where \(\nu^{(k)}\) is given by [[applyg]]

#+NAME: applyg
\begin{equation}
\nu^{(k+1)} = \hat{G}(H)\nu^{(k)}
\end{equation}

Using Eq:[[vecbasis]], Eq:[[applyg]] can be written as [[applyg2]]

#+NAME: applyg2
\begin{equation}
\nu^{(k+1)} = c_0 (1-\tau(E_0-E_T))^{(k)}\mathbf{u_0} + c_1 (1-\tau(E_1-E_T))^{(k)}\mathbf{u_1}
\end{equation}

From Eq:[[applyg2]], we can see that a repeated application of the filter Eq:[[filter]]
with a trial guess energy \(E_T\) will result in the series converging
geometrically to either \(E_0\) or \(E_1\) depending on the choice of \(E_T\).

Here we shall show an example using the Hamiltonian given in Eq:[[mat2x2]]. In the
case of a 2x2 Hamiltonian, and any general trial vector \([c_0,c_1]\), the
recursion relations for the calculation of \(c^{(k)}_0\) and \(c^{(k)}_1\) are
straight forward and given by Eq:[[receqn1]],[[receqn2]].

#+NAME: receqn1
\begin{equation}
c^{(k+1)}_0 =  \left(\mathbf{1}-\tau\left(\nu_0 - E_T\right)\right)c^{(k)}_0 + \tau t c^{(k)}_1
\end{equation}

#+NAME: receqn2
\begin{equation}
c^{(k)}_1 = \tau t c^{(k)}_0 + \left(\mathbf{1}-\tau\left(\nu_1 - E_T\right)\right)c^{(k)}_1
\end{equation}

These are the working equations. As an example, we begin with the initial set of
values given as follows:

#+BEGIN_SRC jupyter-julia :session j1 :results output :exports results
nu0 = 1;
nu1 = 2;
t=1;
tau = 0.1;
ET = 3;
c0=1/sqrt(10);
c1=3/sqrt(10);
ham=[nu0 -t; -t nu1];
println("\\nu_0=",nu0)
println("\\nu_1=",nu1)
println("t=",t)
println("\\tau=",tau)
println("E_T=",ET)
println("c_0=",c0)
println("c_1=",c1)
#+END_SRC

#+ATTR_LATEX: :mode math
#+RESULTS:
#+begin_example
\nu_0=1
\nu_1=2
t=1
\tau=0.1
E_T=3
c_0=0.9486832980505138
c_1=0.31622776601683794
#+end_example

The iteration can begin with these as starting values. The output is given in
shown in the Figure: .

#+BEGIN_SRC jupyter-julia :session j1 :results results :eval noexport :exports results
using Plots
using Plots.PlotMeasures
using LaTeXStrings
#println("| El |\t");
#println("+----+\t");
outputdata=[];
for n in 10:10:80
    ck0=c0;
    ck1=c1;
    for i in 1:n
        tck0=ck0;
        tck1=ck1;
        ck0 = (1-tau*(nu0 - ET))tck0 + t*tau*tck1;
        ck1 = tau*t*tck0 + (1-tau*(nu1-ET))*tck1;
        norm = sqrt(ck0*ck0 + ck1*ck1);
        ck0=ck0/norm;
        ck1=ck1/norm;
    end
    energy = [ck0 ck1] * (ham*[ck0;ck1]);
    energy = (ham*[ck0;ck1])[1]/ck0;
#   println(n,"\t",ck0,"\t",ck1,"\t",energy[1]);
#   println("| ",energy[1]," |");
#   println(energy[1]);
    push!(outputdata,energy[1])
end
savefig(
    plot(1:length(outputdata),outputdata,
         xlabel=L"n",
         ylabel=L"E_L\ ",
         lw=2,
         xlims = (0,9),
         ylims = (0.32,0.42),
         framestyle=:box,
         guidefontsize=10,
         legendfontsize=6,
         thickness_scaling=1.5,
         grid=:none,
         marker=true,
         markersize=2
         )
    ,"/home/vijay/Documents/pedagogical_qmc/figure1.pdf");
#return(outputdata)
#+END_SRC

#+RESULTS:

#+CAPTION: Convergence of the Local energy as a function of iterations.
#+ATTR_LATEX: :width 15cm
#+NAME: figure1
[[/home/vijay/Documents/pedagogical_qmc/figure1.pdf]]
