# -*- mode:org -*-
#+TITLE: QMC Part I
#+AUTHOR: Vijay Gopal Chilkuri
#+EMAIL: vijay.gopal.c@gmail.com
#+OPTIONS: toc:t
#+LATEX_CLASS: article
#+LATEX_HEADER: \usepackage{tabularx}
#+STARTUP: latexpreview hideblocks

* Part I

* Simple power method

** 2x2 Matrix

Consider a Hamiltonian whose matrix form is shown in Eq:[[mat2x2]]. This Hamiltonian
has two eigenvectors and two eigenvalues. Let the two eigenvectors be
\(\mathbf{u_0}\) and \(\mathbf{u_1}\). Then consider \(\mathbf{\nu}\) any arbitrary trial vector which is
not an eigenvector of Eq:[[mat2x2]] but belongs to the 2x2 space. Any such trial vector
can always be written in the form shown in Eq:[[vecbasis]].

#+NAME: mat2x2
#+ATTR_LATEX: :mode math :environment bmatrix :align cc
#+tblname: mat2x2
| v_0 | -t  |
| -t  | v_1 |

#+NAME: vecbasis
\begin{equation}
\mathbf{\nu} = c_0 \mathbf{u_0} + c_1 \mathbf{u_1}
\end{equation}

The key idea is the realization that the ground state of the Hamiltonian [[mat2x2]]
given by \(\mathbf{u_0}\) can be extracted from \(\mathbf{\nu}\) by the repeated
application of a filter \( G(H) \). This filter systematically purifies
\(\mathbf{\nu}\) to obtain the ground state \(\mathbf{u_0}\) provided \(c_0 > 0\),
i.e. the trial vector \(\mathbf{\nu}\) has a non-zero projection on the
ground state.

The form of the filter is inspired from the power method where a successive
application of the Hamiltonian followed by the substraction of the residual
leads to a convergent series of vectors. The limiting value of this convergent
series is one of the extremal eigenvectors of the Hamiltonian. Following this, our filter \(G(H)\) can be written as [[filter]]

#+NAME: filter
\begin{equation}
\hat{G}(H) = \left ( \mathbf{1} - \tau (\hat{H} - E_T\mathbf{1}) \right)
\end{equation}

The convergent series of vectors is then \(\left\{ \nu^{(0)},  \nu^{(1)},\
\nu^{(2)},\dots,\nu^{(n)}\right\}\) where \(\nu^{(k)}\) is given by [[applyg]]

#+NAME: applyg
\begin{equation}
\nu^{(k+1)} = \hat{G}(H)\nu^{(k)}
\end{equation}

Using Eq:[[vecbasis]], Eq:[[applyg]] can be written as [[applyg2]]

#+NAME: applyg2
\begin{equation}
\nu^{(k+1)} = c_0 (1-\tau(E_0-E_T))^{(k)}\mathbf{u_0} + c_1 (1-\tau(E_1-E_T))^{(k)}\mathbf{u_1}
\end{equation}

From Eq:[[applyg2]], we can see that a repeated application of the filter Eq:[[filter]]
with a trial guess energy \(E_T\) will result in the series converging
geometrically to either \(E_0\) or \(E_1\) depending on the choice of \(E_T\).

Here we shall show an example using the Hamiltonian given in Eq:[[mat2x2]]. In the
case of a 2x2 Hamiltonian, and any general trial vector \([c_0,c_1]\), the
recursion relations for the calculation of \(c^{(k)}_0\) and \(c^{(k)}_1\) are
straight forward and given by Eq:[[receqn1]],[[receqn2]].

#+NAME: receqn1
\begin{equation}
c^{(k+1)}_0 =  \left(\mathbf{1}-\tau\left(\nu_0 - E_T\right)\right)c^{(k)}_0 + \tau t c^{(k)}_1
\end{equation}

#+NAME: receqn2
\begin{equation}
c^{(k+1)}_1 = \tau t c^{(k)}_0 + \left(\mathbf{1}-\tau\left(\nu_1 - E_T\right)\right)c^{(k)}_1
\end{equation}

These are the working equations. As an example, we begin with the initial set of
values given as follows:

#+BEGIN_SRC jupyter-julia :session j1 :results output :exports results
using LinearAlgebra
nu0 = 1;
nu1 = 2;
t=1;
tau = 0.1;
ET = 3;
c0=1/sqrt(10);
c1=3/sqrt(10);
nsteps = 1024;
ham=[nu0 -t; -t nu1];
e_exact,vec_exact = eigen(ham)
println("\\nu_0=",nu0)
println("\\nu_1=",nu1)
println("t=",t)
println("\\tau=",tau)
println("E_T=",ET)
println("E_ex=",e_exact)
println("c_0=",c0)
println("c_1=",c1)
println("nsteps=",nsteps);
#+END_SRC

#+RESULTS:
: \nu_0=1
: \nu_1=2
: t=1
: \tau=0.1
: E_T=3
: E_ex=[0.38196601125010515, 2.618033988749895]
: c_0=0.31622776601683794
: c_1=0.9486832980505138
: nsteps=1024

#+ATTR_LATEX: :mode math

The iteration can begin with these as starting values. The output is given in
shown in the Figure:[[figure1]].

#+BEGIN_SRC jupyter-julia :session j1 :results results :eval noexport :exports results
using Plots
using Plots.PlotMeasures
using LaTeXStrings
#println("| El |\t");
#println("+----+\t");
outputdata=[];
for n in 10:10:80
    ck0=c0;
    ck1=c1;
    for i in 1:n
        tck0=ck0;
        tck1=ck1;
        ck0 = (1-tau*(nu0 - ET))tck0 + t*tau*tck1;
        ck1 = tau*t*tck0 + (1-tau*(nu1-ET))*tck1;
        norm = sqrt(ck0*ck0 + ck1*ck1);
        ck0=ck0/norm;
        ck1=ck1/norm;
    end
    energy = [ck0 ck1] * (ham*[ck0;ck1]);
    energy = (ham*[ck0;ck1])[1]/ck0;
#   println(n,"\t",ck0,"\t",ck1,"\t",energy[1]);
#   println("| ",energy[1]," |");
#   println(energy[1]);
    push!(outputdata,energy[1])
end
plt= plot(1:length(outputdata),outputdata,
         xlabel=L"n",
         ylabel=L"E_0",
         lw=2,
         xlims = (0,9),
         ylims = (0.32,0.42),
         framestyle=:box,
         guidefontsize=10,
         legendfontsize=6,
         thickness_scaling=1.5,
         grid=:none,
         marker=true,
         markersize=2
         );
plot!([e_exact[1]],seriestype=:hline);
savefig(
     plt
    ,"/home/vijay/Documents/pedagogical_qmc/figure1.pdf");
#return(outputdata)
#+END_SRC

#+RESULTS:

#+CAPTION: Convergence of the Local energy as a function of iterations.
#+ATTR_LATEX: :width 15cm
#+NAME: figure1
[[/home/vijay/Documents/pedagogical_qmc/figure1.pdf]]

** 3x3 Matrix

A demonstration of all the different variants of QMC requires more than two states. Here we show a Hamiltonian with 3 states. The matrix form of the Hamiltonian is shown in Eq:[[mat3x3]].

#+NAME: mat3x3
#+ATTR_LATEX: :mode math :environment bmatrix :align cc
| v_0 | -t  | -t  |
| -t  | v_1 | -t  |
| -t  | -t  | v_2 |

The trial vector can be written as shown in Eq:[[trial3x3]].

#+NAME: trial3x3
\begin{equation}
\nu = c_0\mathbf{u}_0 + c_1\mathbf{u}_1 + c_2\mathbf{u}_2
\end{equation}

The three coefficients required are \(c_0\), \(c_1\), and \(c_2\). The recurrence relations for
the three coefficients shown in Eq:[[applyg3x3]], Eq:[[receqn3]], Eq:[[receqn4]], and Eq:[[receqn5]].

#+NAME: applyg3x3
\begin{equation}
\nu^{(k+1)} = c_0 (1-\tau(E_0-E_T))^{(k)}\mathbf{u_0} + c_1 (1-\tau(E_1-E_T))^{(k)}\mathbf{u_1}
            + c_2 (1-\tau(E_1-E_T))^{(k)}\mathbf{u_2}
\end{equation}

#+NAME: receqn3
\begin{equation}
c^{(k+1)}_0 =  \left(\mathbf{1}-\tau\left(\nu_0 - E_T\right)\right)c^{(k)}_0 + \tau t c^{(k)}_1 + \tau t c^{(k)}_2
\end{equation}

#+NAME: receqn4
\begin{equation}
c^{(k+1)}_1 = \tau t c^{(k)}_0 + \left(\mathbf{1}-\tau\left(\nu_1 - E_T\right)\right)c^{(k)}_1 + \tau t c^{(k)}_2
\end{equation}

#+NAME: receqn5
\begin{equation}
c^{(k+1)}_2 = \tau t c^{(k)}_0 + \tau t c^{(k)}_1 + \left(\mathbf{1}-\tau\left(\nu_2 - E_T\right)\right)c^{(k)}_2
\end{equation}

#+BEGIN_SRC jupyter-julia :session j1 :results output :exports results
using LinearAlgebra
nu0 = 1;
nu1 = 2;
nu2 = 3;
t=1;
tau = 0.05;
ET = 3;
c0= 1/sqrt(6);
c1=-2/sqrt(6);
c2= 1/sqrt(6);
ham=[nu0 -t -t; -t nu1 -t; -t -t nu2];
e_exact,vec_exact = eigen(ham)
nsteps = 1024;
println("\\nu_0=",nu0)
println("\\nu_1=",nu1)
println("\\nu_2=",nu2)
println("t=",t)
println("\\tau=",tau)
println("E_T=",ET)
println("Exact En=",e_exact)
println("Exact Eval=",vec_exact[:,1])
println("c_0=",c0)
println("c_1=",c1)
println("c_1=",c2)
println("nsteps=",nsteps)
#+END_SRC

#+ATTR_LATEX: :mode math
#+RESULTS:
#+begin_example
\nu_0=1
\nu_1=2
\nu_2=3
t=1
\tau=0.05
E_T=3
Exact En=[-0.21431974337752946, 2.539188872810889, 3.675130870566646]
Exact Eval=[-0.7557893406837775, -0.5206573684395936, -0.397112549787007]
c_0=0.4082482904638631
c_1=-0.8164965809277261
c_1=0.4082482904638631
nsteps=1024
#+end_example


The iteration can begin with these as starting values. The output is given in
shown in the Figure:[[figure2]].

#+BEGIN_SRC jupyter-julia :session j1 :results results :eval noexport :exports results
using Plots
using Plots.PlotMeasures
using LaTeXStrings
#println("| El |\t");
#println("+----+\t");
outputdata=[];
for n in 10:10:80
    ck0=c0;
    ck1=c1;
    ck2=c2;
    for i in 1:n
        tck0=ck0;
        tck1=ck1;
        tck2=ck2;
        ck0 = (1-tau*(nu0-ET))*tck0 + t*tau*tck1 + t*tau*tck2;
        ck1 = tau*t*tck0 + (1-tau*(nu1-ET))*tck1 + t*tau*tck2;
        ck2 = tau*t*tck0 + tau*t*tck1 + (1-tau*(nu2-ET))*tck2;
        norm = sqrt(ck0*ck0 + ck1*ck1 + ck2*ck2);
        ck0=ck0/norm;
        ck1=ck1/norm;
        ck2=ck2/norm;
    end
    energy = [ck0 ck1 ck2] * (ham*[ck0;ck1;ck2]);
    energy = (ham*[ck0;ck1;ck2])[2]/ck1;
#   println(n,"\t",ck0,"\t",ck1,"\t",ck2,"\tnorm=",norm);
#   println("| ",energy[1]," |");
#   println(energy[1]);
    push!(outputdata,energy[1])
end
plt = plot(1:length(outputdata),outputdata,
         xlabel=L"n",
         ylabel=L"E_0",
         lw=2,
         xlims = (0,9),
         ylims = (-4.80, 5.50),
         framestyle=:box,
         guidefontsize=10,
         legendfontsize=6,
         thickness_scaling=1.5,
         grid=:none,
         marker=true,
         markersize=2
         );
plot!([e_exact[1]],seriestype=:hline);
savefig(
    plt
    ,"/home/vijay/Documents/pedagogical_qmc/figure2.pdf");
#return(outputdata)
#+END_SRC

#+RESULTS:


#+CAPTION: Convergence of the Local energy as a function of iterations.
#+ATTR_LATEX: :width 15cm
#+NAME: figure2
[[/home/vijay/Documents/pedagogical_qmc/figure2.pdf]]


#+LATEX: \newpage
* Pure Diffusion Monte Carlo (PDMC)

The basic idea is the same, i.e. applying the power method to converge to the
ground state. However, the integration over \(n\) is done stochastically as
shown in Eq:[[stoch1]].

#+NAME: stoch1
\begin{equation}
E_0 = \frac{E_L(i_0) + E_L(i_1) + E_L(i_2) + \dots}{1 + 1 + 1 + \dots}
\end{equation}

#+NAME: stoch1
\begin{equation}
E_1 = \frac{E_L(i_1) w_{i_0 i_1} + E_L(i_2) w_{i_1 i_2} + E_L(i_3) w_{i_2 i_3} + \dots}{w_{i_0 i_1} + w_{i_1 i_2} + w_{i_2 i_3} + \dots}
\end{equation}

#+NAME: stoch1
\begin{equation}
E_2 = \frac{E_L(i_2) w_{i_0 i_1}w_{i_1 i_2} + E_L(i_3) w_{i_1 i_2}w_{i_2 i_3} + E_L(i_4) w_{i_2 i_3}w_{i_3 i_4} + \dots}{w_{i_0 i_1}w_{i_1 i_2} + w_{i_1 i_2}w_{i_2 i_3} + w_{i_2 i_3}w_{i_3 i_4} + \dots}
\end{equation}


** A simple implementation of PDMC

#+BEGIN_SRC jupyter-julia :session j1 :results output :eval noexport :exports results
nu0 = 1;
nu1 = 2;
t=1;
tau = 0.1;
ET = 3;
c0=1/sqrt(2);
c1=1/sqrt(2);
nsteps = 1024;
niter = 200;
nruns = 20;
ham=[nu0 -t; -t nu1];
#+END_SRC

#+RESULTS:

*** Calculate Local Energy (\(E_L\))

#+BEGIN_SRC jupyter-julia :session j1 :results output :eval noexport :exports results
function getEL(ham, vi, i)
    return ((ham*transpose(vi))[i]/vi[i])
end
#+end_src

#+RESULTS:

*** Calculate the probability (\(P_{i\rightarrow j}\))

#+BEGIN_SRC jupyter-julia :session j1 :results results :eval noexport :exports results
function getPij(ham, tau, EL, i, j, vec)
    dim = size(ham)[1];
    idmat = Matrix(1.0*I,dim,dim);
    numer = vec[j] * (idmat - tau * (ham - EL*idmat))[i,j];
    denom = vec[i];
    return(numer/denom)
end
#+end_src

#+RESULTS:
: getPij (generic function with 1 method)

*** Calculate the weights (\(w_{i_1 i_2}\))

#+BEGIN_SRC jupyter-julia :session j1 :results results :eval noexport :exports results
using LinearAlgebra
function getWeightij(ham, tau, ET, EL, i, j)
    dim = size(ham)[1];
    idmat = Matrix(1.0*I,dim,dim);
    numer = (idmat - tau * (ham - ET*idmat))[i,j];
    denom = (idmat - tau * (ham - EL*idmat))[i,j];
    return(numer/denom)
end
#+end_src

#+RESULTS:
: getWeightij (generic function with 1 method)

*** Combine \(E_L\) and \(w_{ij}\) to do PDMC

The simulation requires the calculation of a markov chain \(i_0, i_1, i_2,
\dots\). This is generated by picking a random number \(\epsilon\) and choosing
\(1, 2,\) or \(3\) according to what \(3 \epsilon\) is.

The iteration can begin with these as starting values. The output is given in
shown in the Figure:[[figure3]].

#+BEGIN_SRC jupyter-julia :session j1 :results output :exports results
nu0 = 1;
nu1 = 2;
t=1;
tau = 0.1;
ET = 3;
c0=1/sqrt(2);
c1=1/sqrt(2);
nsteps = 424;
niter = 200;
nruns = 200;
ham=[nu0 -t; -t nu1];
e_exact,vec_exact = eigen(ham)
# println("\\nu_0=",nu0)
# println("\\nu_1=",nu1)
# println("t=",t)
# println("\\tau=",tau)
# println("E_T=",ET)
# println("c_0=",c0)
# println("c_1=",c1)
#+END_SRC

#+RESULTS:

#+BEGIN_SRC jupyter-julia :session j1 :results results :eval noexport :exports results
using Plots
using Plots.PlotMeasures
using LaTeXStrings
using Statistics
#println("| El |\t");
#println("+----+\t");
totaldata = zeros(niter,nruns)
alldata = zeros(nruns,niter)
totalEW     = zeros(nruns,niter)
totalweight = zeros(nruns,niter)
timesweight = zeros(nruns,niter)
energylist  = zeros(nruns,niter)
weightdata  = zeros(nruns,niter)
oldweightdata  = zeros(nruns,niter)
tmpweight   = zeros(niter)
tmpenergy   = zeros(niter)
avgdata = zeros(niter)
vardata = zeros(niter)
outputdata = [];
listids    = [];
listEL     = [];
listwij    = [];
#vec0 = [c0 c1 c2];
vec0 = [c0 c1];
i = 1;
j = 1;
EL = getEL(ham, [c0 c1], i)
push!(listids,i);
push!(listEL,getEL(ham,vec0, i));
EL = listEL[end];
push!(listwij,1.0);
EL = getEL(ham, [c0 c1], 1)
EL1 = EL;
w11 = getWeightij(ham, tau, ET, EL1, 1, 1);
w12 = getWeightij(ham, tau, ET, EL1, 1, 2);
p11 = getPij(ham, tau, EL, 1, 1, [c0 c1])
p12 = getPij(ham, tau, EL, 1, 2, [c0 c1])
EL = getEL(ham, [c0 c1], 2)
EL2 = EL;
w21 = getWeightij(ham, tau, ET, EL2, 2, 1);
w22 = getWeightij(ham, tau, ET, EL2, 2, 2);
p21 = getPij(ham, tau, EL, 2, 1, [c0 c1])
p22 = getPij(ham, tau, EL, 2, 2, [c0 c1])
pij = Dict(1=>p11,2=>p22);
swapij = Dict(1=>2,2=>1);
elij = Dict(1=>EL1,2=>EL2);
weightij = Dict((1,1)=>w11,(1,2)=>w12,(2,1)=>w12,(2,2)=>w22);
for irun in 1:nruns
    # fill up initial block
    for p in 1:niter
        #   i = trunc(Int,floor(2*rand()))+1;
        if rand() > pij[j]
            j = swapij[j]
        end
        if(p==1)
            weightdata[irun,p] = 1;
            oldweightdata[irun,p] = 1;
        else
            weightdata[irun,p] = weightij[(i,j)];
            oldweightdata[irun,p] = weightij[(i,j)];
        end
        energylist[irun,p] = elij[j];
        i = j;
    end

    # calculate the sum of product of weights
    map(x->timesweight[irun,x] =foldl(*,weightdata[irun,1:x]),collect(1:niter));

    i = 1;
    j = 1;
    # do the iterations
    for p in 1:nsteps
        #   i = trunc(Int,floor(2*rand()))+1;
        if rand() > pij[j]
            j = swapij[j]
        end

        # rotate energy window
        for idxi = 2:niter
            energylist[irun,idxi-1] = energylist[irun,idxi]
        end
        energylist[irun,end]= elij[j];

        # calculate the weighted eneries
        for idxi = 1:niter
            totalEW[irun,idxi] += energylist[irun,idxi]*timesweight[irun,idxi]
        end

        # calculate the sum of weights
        for idxi = 2:niter
            totalweight[irun,idxi] += timesweight[irun,idxi]
        end

        # rotate weight window
        for idxi = 3:niter
            weightdata[irun,idxi-1] = weightdata[irun,idxi]
        end
        weightdata[irun,1]= 1;
        weightdata[irun,end] = weightij[(i,j)];

        # calculate the sum of product of weights
        for idxi = 2:niter
            timesweight[irun,idxi] *= weightdata[irun,idxi]/oldweightdata[irun,2];
        end

        # set old weights
        for idxi = 1:niter
            oldweightdata[irun,idxi] = weightdata[irun,idxi]
        end

        i = j;
    end
    for j in 1:niter
       totaldata[j,irun] = totalEW[irun,j]/totalweight[irun,j]
    end
end
for i in 1:niter
    avgdata[i] = mean(totaldata[i,:])
    vardata[i] = var(totaldata[i,:])
end
plt=plot(collect(1:niter),avgdata,
         xlabel=L"n",
         ylabel=L"E_0",
#        lw=2,
         xlims = (0,niter),
         ylims = (0.36,0.48),
         framestyle=:box,
         guidefontsize=10,
         legendfontsize=6,
        thickness_scaling=1.5,
         grid=:none,
         marker=true,
         markersize=2,
        ribbon=vardata
         )
#plot!([e_exact[1]],seriestype=:hline);
savefig(
    plt
    ,"/home/vijay/Documents/pedagogical_qmc/figure3.pdf");
#+end_src

#+RESULTS:

#+CAPTION: Convergence of the Local energy as a function of iterations(PDMC).
#+ATTR_LATEX: :width 15cm
#+NAME: figure3
[[/home/vijay/Documents/pedagogical_qmc/figure3.pdf]]

*** Conclusion

#+begin_src jupyter-julia :session j1
tmpa = zeros(2,10)
tmpb = zeros(2,10)
for i in 1:100000000
    rand()
    circshift!(tmpb,tmpa,10)
end
#+end_src

#+RESULTS:

#+begin_src C
#include <stdio.h>
#include <stdlib.h>

int main()
{
    float *array = (float *)malloc(10000*sizeof(float));
    time_t t;
    printf("Doing\n");
    srand((unsigned)time(&t));
    for(int i=0;i<10000;++i)
    {
        for(int j=0;j<10000;++j)
        {
            if(rand()>0.5)
            {
              rand();
              array[j];
            }
            else
            {
              rand();
              array[j];
            }
        }
    }
    printf("Done\n");

    free(array);
    return(0);
}

#+end_src

#+RESULTS:
| Doing |
| Done  |
